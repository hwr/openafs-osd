<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    -->
<BODY bgcolor="ffffff">
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<HR><H1><A NAME="HDRWQ142" HREF="auagd002.htm#ToC_164">서버 프로세스 모니터 및 제어</A></H1>
<A NAME="IDX6247"></A>
<A NAME="IDX6248"></A>
<P>시스템 관리자의 가장 중요한 책임 중 하나는 파일 서버 시스템의 프로세스가
제대로 실행되고 있는지 확인하는 것입니다.
모든 파일 서버 시스템에서 실행되는 BOS 서버는 시스템 상의 다른 AFS 서버
프로세스를 계속 모니터하여 여러분의 책임을 많이 덜어 줍니다. 또한 실패한
프로세스를 자동으로 재시작하고 상호 의존성을 고려하여 재시작 순서를
지정할 수 있습니다.
<P>여러 다른 파일 서버 시스템에서 다른 프로세스들이 함께 실행되므로
각 파일 서버 시스템의 BOS 서버가 모니터해야 할 프로세스를 정의해야
합니다 (<A HREF="#HDRWQ154">프로세스 상태 제어 및 확인</A> 참고).
<P>BOS 서버가 수정할 수 있는 루틴 유지관리를 수행하거나 문제점(예: 데이터베이스
복제 또는 상호 인증과 관련된 문제)을 수정하기 전에 서버 프로세스 상태를
직접 제어하는 것이 필요할 수 있습니다. 이러한 경우에
<B>bos</B> 명령을 실행하여 BOS 서버를 통해 프로세스 상태를
제어해야 합니다.
<HR><H2><A NAME="HDRWQ143" HREF="auagd002.htm#ToC_165">명령어(instruction) 요약</A></H2>
<P>이 장에서는 지정된 명령을 사용하여 다음 타스크를 수행하는 방법을 설명합니다.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">프로세스 상태 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos status</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%"><B>BosConfig file</B> 파일의 정보 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos status</B> 명령과
<B>-long</B> 플래그
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">프로세스 인스턴스 작성
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos create</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">프로세스 정지
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos stop</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">정지된 프로세스 시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos start</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">프로세스 일시 정지
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos shutdown</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">일시 정지된 프로세스 시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos startup</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">프로세스 정지 후 즉시 재시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos restart</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">모든 프로세스 정지 후 즉시 재시작
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos restart</B> 명령과 함께
<B>-bosserver</B> 플래그
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">BOS 서버의 재시작 시간 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos getrestart</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">BOS 서버의 재시작 시간 설정
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos setrestart</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">로그 파일 검토
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos getlog</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="58%">원격으로 명령 실행
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="42%"><B>bos exec</B>
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ145" HREF="auagd002.htm#ToC_166">AFS 서버 프로세스에 대한 간단한 설명</A></H2>
<P>이 절에서는 AFS 서버 시스템에서 실행될 수 있는 여러 다른 서버 프로세스를
설명합니다. 다중 서버 시스템이 있는 셀의 모든 시스템에서 모든 프로세스가
반드시 실행되는 것은 아닙니다.
<P>AFS 서버 프로세스는 그 컨텍스트에 따라 다음의 세 가지 방식으로 언급됩니다.
<A NAME="IDX6249"></A>
<UL>
<LI><B>bos status</B> 명령의 출력은
<B>bos create</B> 명령이 <B>/usr/afs/local/BosConfig</B>
파일에 해당 항목을 작성할 때 지정된 이름에 의해 프로세스를 참조합니다.
이름은 시스템마다 다를 수 있으나 모든 시스템에 동일한 이름을 지정하는 경우
셀을 가장 쉽게 유지 관리할 수 있습니다. <I>AFS 빠른 시작</I> 및
<B>bos create</B> 명령에 대한 참조 페이지에서는 일반적인
이름을 나열합니다. <B>bosserver</B>, <B>kaserver</B> 및 <B>vlserver</B>를 예로 들 수 있습니다.
</LI><LI>표준 <B>ps</B> 명령이 생성한 프로세스 목록은 프로세스의
2진 파일과 보통 일치합니다. 프로세스 2진 파일의 예로
<B>/usr/afs/bin/bosserver</B>, <B>/usr/afs/bin/kaserver</B> 및 <B>/usr/afs/bin/vlserver</B>를
들 수 있습니다.
</LI><LI>문서에 나오는 대부분의 참조를 포함하는 대부분의 컨텍스트에서
프로세스는 (예를 들면) <B>BOS(Basic OverSeer)
서버</B>, <B>인증 서버</B> 또는 <B>볼륨 위치 서버</B>로 참조됩니다.
</LI></UL>
<P>다음 절에서는 이러한 프로세스를 사용하게 되는 일부 관리 타스크와
프로세스의 각 이름을 지정합니다. 서버에 대한 좀더 일반적인 설명을
보려면 <A HREF="auagd006.htm#HDRWQ17">AFS 서버 프로세스 및 캐쉬 관리 프로그램</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ146" HREF="auagd002.htm#ToC_167">bosserver 프로세스: BOS(Basic OverSeer) 서버</A></H3>
<A NAME="IDX6250"></A>
<A NAME="IDX6251"></A>
<P>모든 AFS 서버 시스템에서 실행되는 <B>bosserver</B> 프로세스는
시스템에서 실행되는 다른 AFS 서버 프로세스를 모니터하는 책임을 맡은
BOS(Basic OverSeer) 서버입니다. 프로세스가 실패하면 BOS 서버는 사용자가
개입하지 않아도 프로세스를 자동으로 재시작할 수 있습니다. 또한 다중
구성요소 프로세스(예: <A HREF="#HDRWQ148">fs 프로세스 모음: 파일 서버, 볼륨 서버 및 구조 프로그램</A>에서 설명하는
<B>fs</B> 프로세스)를 가진 프로세스를 재시작할 때 상호
의존성을 고려합니다.
<A NAME="IDX6252"></A>
<P>BOS 서버는 자신을 모니터하거나 재시작하지 않으므로 <B>bos
status</B> 명령의 출력에 나타나지 않습니다. 이 서버는
<B>ps</B> 명령의 출력에 <TT>/usr/afs/bin/bosserver</TT>로서
나타납니다.
<A NAME="IDX6253"></A>
<A NAME="IDX6254"></A>
<P>시스템 관리자라면 <B>bos</B> 명령을 실행하여 다음 유형의
타스크를 수행할 때 BOS 서버에 접속해야 합니다.
<A NAME="IDX6255"></A>
<UL>
<LI><A HREF="#HDRWQ154">프로세스 상태 제어 및 확인</A>에서 설명하는 것처럼
<B>/usr/afs/local/BosConfig</B> 파일에 항목을 작성하여
BOS 서버가 모니터할 프로세스 정의
</LI><LI>이 장의 후속 지침에 따라 파일 서버 시스템에서 프로세스 정지 및 시작
</LI><LI><A HREF="auagd008.htm#HDRWQ118">서버 CellServDB 파일 유지</A>에서 설명하는 것처럼 <B>/usr/afs/etc/CellServDB</B> 파일에서 셀의 데이터베이스 서버 시스템 정의
</LI><LI><A HREF="auagd014.htm#HDRWQ355">서버 암호화 키 관리</A>에서 설명하는 것처럼 <B>/usr/afs/etc/KeyFile</B> 파일에 AFS 서버 암호화 키 정의
</LI><LI><A HREF="auagd021.htm#HDRWQ592">UserList 파일 관리</A>에서 설명하는 것처럼 사용자를 <B>서버 조작에 대한 시스템 관리자 권한을 부여</B>
</LI><LI><A HREF="auagd008.htm#HDRWQ123">인증 관리 및 권한 부여 요구조건</A>에서 설명하는 것처럼 서버 시스템에
권한 확인 요구조건 설정
</LI></UL>
<P><H3><A NAME="HDRWQ147" HREF="auagd002.htm#ToC_168">buserver 프로세스: 백업 서버</A></H3>
<A NAME="IDX6256"></A>
<A NAME="IDX6257"></A>
<P>데이터베이스 서버 시스템에서 실행되는 <B>buserver</B>는
백업 서버입니다. 이 서버는 백업 시스템 구성 및 백업 데이터베이스의
조작에 대한 정보를 유지 관리합니다.
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos
status</B> 명령 출력에서 <TT>buserver</TT>로 나타납니다.
이 서버는 <B>ps</B> 명령의 출력에 <TT>/usr/afs/bin/buserver</TT>로서
나타납니다.
<A NAME="IDX6258"></A>
<A NAME="IDX6259"></A>
<P>시스템 관리자라면 볼륨에서 영구 기억영역으로 데이터를 덤프하거나 데이터를
AFS로 복원하는 백업 데이터베이스에 백업 시스템 구성 정보를 변경하는
것과 같은 정보를 처리하는 <B>backup</B> 명령을 실행할 때
백업 서버에 접속해야 합니다. <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A> 및
<A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ148" HREF="auagd002.htm#ToC_169">fs 프로세스 모음: 파일 서버, 볼륨 서버 및 구조 프로그램</A></H3>
<A NAME="IDX6260"></A>
<A NAME="IDX6261"></A>
<P>모든 파일 서버 시스템에서 실행되는 <B>fs</B> 프로세스는
파일 서버, 볼륨 서버 및 구조 프로그램의 세 가지 구성요소 프로세스를
조합합니다.
세 가지 구성요소는 독립적인 기능을 수행하지만 다음 이유로 인해 단일
프로세스로 제어됩니다.
<UL>
<LI>이들은 모두 동일한 데이터, 즉 AFS 볼륨에 저장된 파일과 디렉토리에 대해
작동합니다. 이들을 단일 프로세스로 조합함으로써 해당 작업이 통합될 수 있으며
데이터에 손상을 일으킬 수 있는, 동일한 데이터에 대한 동시 작업을 시도하지
않습니다.
</LI><LI>또한 BOS 서버가 필요한 순서대로 프로세스를 정지 및 재시작할 수 있게
해 줍니다. 파일 서버에 장애가 발생하면 BOS 서버는 볼륨 서버를 중지하고
구조 프로그램을 실행하여 장애로 인해 발생한 손상을 수정합니다.
(구조 프로그램은 이러한 특수 상황에서나 사용자가 <A HREF="auagd010.htm#HDRWQ232">볼륨 구조</A>의
지침에 따라 <B>bos salvage</B> 명령을 실행하여
직접 이 프로그램을 호출할 때만 실행됩니다.) 볼륨 서버에만 장애가 발생하면
BOS 서버는 파일 서버나 구조 프로그램에 영향을 미치지 않고 볼륨 서버를
재시작할 수 있습니다.
</LI></UL>
<P>파일 서버 구성요소는 파일 및 디렉토리 레벨에서 AFS 데이터를 처리하고
응용 프로그램과 표준 운영 체제 명령에서 요구하는 대로 파일 시스템 요소를
처리합니다. 그 기본 임무는 요청된 파일을 클라이언트 시스템을 전달하고
클라이언트가 종료될 때 이들 파일을 다시 서버 시스템에 저장하는 것입니다.
또한 각 파일 및 디렉토리에 대한 상태 및 보호 정보를 유지 관리하기도 합니다.
이 구성요소는 정상 작동 중에 계속 실행됩니다.
<A NAME="IDX6262"></A>
<P>볼륨 서버 구성요소는 파일 및 디렉토리 레벨이 아닌 완전한 볼륨 레벨에서
AFS 데이터를 처리합니다. <B>vos</B> 명령이 실행될 경우
이 구성요소는 다른 작업 도중에 전체 볼륨을 작성, 제거, 이동, 덤프 및
복원합니다. 이 구성요소는 정상 작동 중에 계속 실행됩니다.
<A NAME="IDX6263"></A>
<P>구조 프로그램 구성요소는 다른 두 프로세스 중 하나에 장애가 발생한 후에만
실행됩니다. 이 구성요소는 파일 시스템의 내부 일관성을 확인하고 발견한
오류를 수정합니다.
<A NAME="IDX6264"></A>
<A NAME="IDX6265"></A>
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos status</B> 명령 출력에서 <TT>fs</TT>로 나타납니다. 보조 메시지가 나타나서
파일 서버 또는 구조 프로그램 구성요소의 상태를 보고합니다.<A HREF="#HDRWQ158">프로세스 상태와 BosConfig 파일의 정보 표시하기</A>를 참조하십시오.
<P><B>fs</B> 프로세스의 구성요소 프로세스는 다음과 같이
<B>ps</B> 명령 출력에서 개별적으로 나타납니다.
<TT>fs</TT> 프로세스 자체에 대한 항목은 없습니다.
<UL>
<LI><TT>/usr/afs/bin/fileserver</TT>
</LI><LI><TT>/usr/afs/bin/volserver</TT>
</LI><LI><TT>/usr/afs/bin/salvager</TT>
</LI></UL>
<P>캐쉬 관리 프로그램은 AFS 파일 또는 디렉토리의 데이터나 상태 정보를 액세스할
때마다 또는 UNIX <B>cp</B> 및 <B>ls</B>
명령과 같은 파일 처리 명령을 실행할 때 사용자 대신 파일 서버 구성요소에
접속합니다. 사용자는 다음 기능을 수행하는 <B>fs</B> 명령을
실행하여 파일 서버에 직접 접속할 수 있습니다.
<A NAME="IDX6266"></A>
<A NAME="IDX6267"></A>
<UL>
<LI><A HREF="auagd020.htm#HDRWQ562">액세스 제어 목록 관리</A>에서 설명하는 것처럼 파일 시스템에 있는
디렉토리의 ACL 관리
</LI><LI>AFS 볼륨을 저장하는 새 파티션 설치. 이 경우 새 파티션에 대해
<B>fs</B> 프로세스를 재시작하여 새 파티션을 인식하게
해야 합니다. 지침을 보려면 <A HREF="auagd008.htm#HDRWQ130">디스크 및 파티션 추가 또는 제거</A>를 참조하십시오.
</LI><LI><A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>에서 설명하는 것처럼 AFS 파일 공간에서
볼륨 마운트 포인트 작성 및 삭제
</LI><LI><A HREF="auagd010.htm#HDRWQ234">볼륨 할당량과 현재 크기 설정 및 표시</A>에서 설명하는 것처럼 볼륨 할당량을 설정하고
볼륨이나 파티션에서 사용되거나 사용할 수 있는 공간에 대한 정보 표시
</LI></UL>
<A NAME="IDX6268"></A>
<A NAME="IDX6269"></A>
<P>볼륨을 작성, 제거, 복제, 이동, 이름 변경, 다른 형식으로 변경 또는
구조하는 등의 방법으로 볼륨을 처리하는 <B>vos</B> 명령을
실행할 때 볼륨 서버 구성요소를 접속해야 합니다.
지침을 보려면 <A HREF="auagd010.htm#HDRWQ174">볼륨 관리</A>를 참조하십시오.
<P>구조 프로그램은 보통 장애가 발생하는 경우에 자동으로 실행됩니다.
<A HREF="auagd010.htm#HDRWQ232">볼륨 구조</A>에서 설명하는 것처럼 <B>bos salvage</B>
명령을 사용하여 구조 프로그램을 시작할 수도 있습니다.
<A NAME="IDX6270"></A>
<A NAME="IDX6271"></A>
<P><H3><A NAME="HDRWQ149" HREF="auagd002.htm#ToC_170">kaserver 프로세스: 인증 서버</A></H3>
<A NAME="IDX6272"></A>
<A NAME="IDX6273"></A>
<P>데이터베이스 서버 시스템에서 실행되는 <B>kaserver</B>
프로세스는 AFS 보안의 여러 측면을 담당하는 인증 서버입니다. 이 서버는
암호를 요구하여 AFS 사용자의 신원을 확인합니다. 또한 인증 데이터베이스에
모든 AFS 서버 암호화 키와 사용자 암호를 유지 관리합니다.
인증 서버의 티켓 부여 서비스(TGS) 모듈은 AFS 클라이언트 및 서버 프로세스가
보안 연결을 형성할 때 사용하는 공유 비밀을 작성합니다.
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos
status</B> 명령 출력에서 <TT>kaserver</TT>로 나타납니다.
<B>ka</B> 문자열은 <I>Kerberos 인증</I>을
상징하는 것으로 AFS의 인증 프로토콜이 원래 Massachusetts Institute of
Technology's Project Athena에서 개발된 Kerberos에 기반을 두고 있음을
반영합니다.
<P>이 서버는 <B>ps</B> 명령의 출력에 <TT>/usr/afs/bin/kaserver</TT>로서
나타납니다.
<A NAME="IDX6274"></A>
<A NAME="IDX6275"></A>
<P>시스템 관리자라면 <B>kas</B> 명령을 실행하여 다음 유형의
타스크를 수행할 때 인증 서버에 접속해야 합니다.
<UL>
<LI>사용자의 암호 설정. 사용자들은 보통 자신의 암호를 변경하므로
<A HREF="auagd018.htm#HDRWQ502">AFS 사용자 계정 작성</A> 및 <A HREF="auagd018.htm#HDRWQ516">AFS 암호 변경</A>에서
설명하는 것처럼 새 사용자 계정을 작성하는 데 이 타스크를 사용하게 됩니다.
</LI><LI>TGS에서 서버 티켓을 봉인하는 데 사용한 AFS 서버 암호화 키를
인증 데이터베이스에 설정. <A HREF="auagd014.htm#HDRWQ355">서버 암호화 키 관리</A> 참고.
</LI><LI><A HREF="auagd021.htm#HDRWQ589">kas 명령에 특권 부여:  ADMIN 플래그</A>에서 설명하는 것처럼 인증 서버에
관련된 시스템 관리자 권한 부여 또는 취소.
</LI></UL>
<P><H3><A NAME="HDRWQ150" HREF="auagd002.htm#ToC_171">ptserver 프로세스: 보호 서버</A></H3>
<A NAME="IDX6276"></A>
<A NAME="IDX6277"></A>
<P>데이터베이스 서버 시스템에서 실행되는 <B>ptserver</B>
프로세스는 보호 서버입니다. 그 기본 임무는 사용자, 시스템 및 그룹 항목을
포함하는 보호 데이터베이스를 유지 관리하는 것입니다. 보호 서버는 AFS ID를
할당하고 이들과 이름 간의 맵핑을 유지 관리합니다. 파일 서버는 사용자가
요청된 작업을 수행할 권한이 있는지 확인할 때 보호 서버에 문의합니다.
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos status</B>
명령 출력에서 <TT>ptserver</TT>로 나타납니다.
이 서버는 <B>ps</B> 명령의 출력에 <TT>/usr/afs/bin/ptserver</TT>로서
나타납니다.
<A NAME="IDX6278"></A>
<A NAME="IDX6279"></A>
<P>시스템 관리자라면 <B>pts</B> 명령을 실행하여 다음 유형의
타스크를 수행할 때 보호 서버에 접속해야 합니다.
<UL>
<LI><A HREF="auagd019.htm#HDRWQ531">보호 데이터베이스 관리</A>에서 설명하는 것처럼 보호 데이터베이스에
새 사용자, 시스템 또는 그룹 항목을 작성
</LI><LI><A HREF="auagd019.htm#HDRWQ531">보호 데이터베이스 관리</A>에서 설명하는 것처럼 그룹 구성원 추가하거나
제거 또는 보호 데이터베이스 항목 처리
</LI><LI><A HREF="auagd021.htm#HDRWQ586">system:administrators 그룹 관리</A>에서 설명하는 것처럼
<B>system:administrators</B> 그룹의 멤버쉽을 변경하여
시스템 관리자 권한 부여 또는 취소
</LI></UL>
<P><H3><A NAME="HDRWQ151" HREF="auagd002.htm#ToC_172">runntp 프로세스</A></H3>
<A NAME="IDX6280"></A>
<A NAME="IDX6281"></A>
<A NAME="IDX6282"></A>
<P>모든 서버 시스템에서 실행되는 <B>runntp</B> 프로세스는
서버 시스템의 하드웨어 시계를 동기화하는 NTPD(Network Time Protocol Daemon)에
대한 제어기 프로그램입니다. 아직 서버 시스템에서 NTP나 다른 시간 동기화
프로토콜을 실행하고 있지 않으면 <B>runntp</B> 프로세스를
실행할 수 있습니다.
<P>데이터베이스 서버 시스템의 시계는 AFS의 분산 데이터베이스 기술(Ubik)이
시계의 시간이 큰 차이가 없을 때만 제대로 기능하기 때문에 동기화를
이루어야 합니다(<A HREF="auagd008.htm#HDRWQ103">적절한 Ubik 작업을 위한 셀 구성</A> 참고).
파일 서버 시스템의 시계는 파일 서버가 파일에 수정 시간 소인을 설정할
뿐 아니라 일반적인 구성에서 AFS 클라이언트 시스템에 대한 시간 소스로
작동하기 때문에 잘못되면 안됩니다.
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos status</B> 명령 출력에서 <TT>runntp</TT>로 나타납니다. 이 프로세스는
<B>ps</B> 명령의 출력에서 <TT>/usr/afs/bin/runntp</TT>로서
나타납니다. <B>ps</B> 명령의 출력에는 <TT>ntpd</TT>라는
항목도 들어 있습니다. 그 정확한 양식은 사용자가 <B>runntp</B>
명령에 제공한 인수에 따라 달라집니다.
<A NAME="IDX6283"></A>
<A NAME="IDX6284"></A>
<P>시스템 관리자라면 <I>AFS 빠른 시작</I>의 지침에 따라 NTPD를 설치할 때 직접 NTPD에
접속할 필요가 없습니다.
<P><H3><A NAME="HDRWQ152" HREF="auagd002.htm#ToC_173">upserver 및 upclient 프로세스: 갱신 서버</A></H3>
<A NAME="IDX6285"></A>
<A NAME="IDX6286"></A>
<A NAME="IDX6287"></A>
<P>갱신 서버는 두 가지 별도의 부분으로 구성됩니다. 각각은 다른 유형의 서버
시스템에서 실행됩니다. <B>upserver</B> 프로세스는 갱신
서버의 서버 부분입니다. 그 기능은 다음과 같이 사용하는 AFS 버전에 따라
달라집니다.
<UL>
<LI>미국판 및 각국 언어판을 모두 사용할 경우 갱신 서버는 서버 시스템으로 사용하는
각 시스템 유형의 2진 분산 시스템에서 실행되어 각 <B>/usr/afs/bin</B>
디렉토리의 내용을 해당 유형의 다른 서버 시스템으로 분배합니다. 이를 통해
모든 시스템이 동일한 버전의 AFS 2진 파일을 가지게 됩니다. (2진 파일
목록에 대한 정보를 보려면 <A HREF="auagd008.htm#HDRWQ84">/usr/afs/bin 디렉토리의 2진 파일</A>을 참조하십시오.)
</LI><LI>미국판 AFS를 사용하는 경우 갱신 서버는 셀의 시스템 제어 시스템에서도
실행되어 <B>/usr/afs/etc</B> 디렉토리에 저장된 구성 파일을
동기화하기 위해 이 디렉토리의 내용을 다른 모든 서버 시스템으로
분배합니다(구성 파일 목록을 보려면 <A HREF="auagd008.htm#HDRWQ85">/usr/afs/etc 디렉토리의 일반 구성 파일</A>을 참조하십시오).
</LI></UL>
<P><B>upclient</B> 프로세스는 갱신 서버의 클라이언트
부분으로 서버 부분과 마찬가지로 그 기능은 사용되는 AFS 버전에 따라 달라집니다.
<UL>
<LI>이 프로세스는 2진 분산 시스템이 아닌 모든 서버 시스템에서 실행되며
해당 시스템 유형의 2진 분산 시스템을 <B>/usr/afs/bin</B>
디렉토리에 있는 2진 파일의 갱신 내용에 대한 소스로 참조합니다.
지정되는 일반적인 프로세스 이름은 <B>upclientbin</B>입니다.
</LI><LI>미국판 AFS를 사용하는 경우 다른 프로세스 인스턴스는 시스템 제어 시스템을
제외한 모든 서버 시스템에서 실행됩니다. 이 인스턴스는 시스템 제어
시스템을 <B>/usr/afs/etc</B> 디렉토리의 공통 구성 파일에 대한
갱신 내용의 소스로 참조합니다. 지정되는 일반적인 이름은
<B>upclientetc</B>입니다.
</LI></UL>
<P>일반적인 이름이 지정된 경우 <B>bos status</B> 명령의 출력에서
서버 부분은 <TT>upserver</TT>로 나타나고 클라이언트 부분은 <TT>upclientbin</TT> 및 <TT>upclientetc</TT>로 나타납니다.
<B>ps</B> 명령의 출력에서 서버 부분은
<TT>/usr/afs/bin/upserver</TT>로 나타나고 클라이언트 부분은 <TT>/usr/afs/bin/upclient</TT>로 나타납니다.
<A NAME="IDX6288"></A>
<A NAME="IDX6289"></A>
<P>일단 갱신 서버를 설치했으면 갱신 서버에 직접 접속할 필요가 없습니다.
이 서버는 사용자가 <B>bos</B> 명령을 사용하여 분배하는
파일을 변경할 때마다 자동으로 작동됩니다.
<P><H3><A NAME="HDRWQ153" HREF="auagd002.htm#ToC_174">vlserver 프로세스: 볼륨 위치 서버</A></H3>
<A NAME="IDX6290"></A>
<A NAME="IDX6291"></A>
<P>데이터베이스 서버 시스템에서 실행되는 <B>vlserver</B>
프로세스는 각 볼륨을 저장하는 파일 서버 시스템을 자동으로 추적하여 그 위치를
클라이언트 응용 프로그램에 가시적으로 알려 주는 볼륨 위치(VL) 서버입니다.
<P>일반적인 이름이 지정되는 경우 프로세스는 <B>bos
status</B> 명령 출력에서 <TT>vlserver</TT>로 나타납니다. 이 서버는
<B>ps</B> 명령의 출력에서 <TT>/usr/afs/bin/vlserver</TT>로
나타납니다.
<A NAME="IDX6292"></A>
<A NAME="IDX6293"></A>
<A NAME="IDX6294"></A>
<P>시스템 관리자라면 볼륨의 상태를 변경하는 <B>vos</B>
명령을 실행할 때 VL 서버에 접속해야 합니다(VLDB에 상태 변경 내용을
저장합니다).
<HR><H2><A NAME="HDRWQ154" HREF="auagd002.htm#ToC_175">프로세스 상태 제어 및 확인</A></H2>
<P>서버 시스템에서 실행되는 AFS 서버 프로세스를 정의하려면 <B>bos create</B>
명령을 사용하여 로컬 <B>/usr/afs/local/BosConfig</B> 파일에 이들
프로세스에 대한 항목을 작성하십시오. BOS 서버는 <B>BosConfig</B>
파일에서 <TT>Run</TT> 상태 플래그가 붙은 프로세스를 모니터하고 이들
프로세스에 장애가 발생한 경우 자동으로 재시작을 시도합니다. 프로세스
항목을 작성한 후에 <B>bos</B> 집합으로부터 다른 명령을
사용하여 원하는 대로 프로세스를 정지 및 시작하거나 상태 플래그를
변경할 수 있습니다.
<P><B>bos</B> 명령을 사용하지 않고 직접
<B>BosConfig</B> 파일을 편집하지 않도록 하십시오.
이와 마찬가지로 서버 프로세스를 <B>BosConfig</B> 파일에
나열하지 않고 서버 프로세스를 실행하거나 UNIX <B>kill</B>
명령과 같은 프로세스 종료 명령을 사용하여 프로세스를 정지하는 것은
바람직하지 못합니다.
<P><H3><A NAME="Header_176" HREF="auagd002.htm#ToC_176">BosConfig 파일의 정보</A></H3>
<A NAME="IDX6295"></A>
<A NAME="IDX6296"></A>
<P><B>BosConfig</B> 파일의 프로세스 항목에는 다음 정보가
들어 있습니다.
<UL>
<LI>프로세스의 이름. 권장되는 일반적 이름은 <I>AFS 빠른 시작</I>과
<A HREF="#HDRWQ161">프로세스 작성 및 제거</A>에 정의되어 있습니다. 단순 프로세스의
이름은 그 2진 파일의 이름과 보통 일치합니다(예: 보호 서버의 경우
<B>ptserver</B>).
</LI><LI>그 유형은 다음 중 하나가 될 수 있습니다.
<P>
<DL>
<A NAME="IDX6297"></A>
<A NAME="IDX6298"></A>
<P><DT><B>Simple
</B><DD>서버 시스템의 다른 프로세스와 독립적으로 실행되는 프로세스.
여러 단순 프로세스에서 동시에 장애가 발생하는 경우 BOS 서버는 임의의
순서에 따라 이들 프로세스를 재시작할 수 있습니다. <B>fs</B> 프로세스를 제외한 모든 표준 AFS 프로세스는 단순 프로세스입니다.
<P><DT><B>fs
<A NAME="IDX6299"></A>
<A NAME="IDX6300"></A>
<A NAME="IDX6301"></A>
<A NAME="IDX6302"></A>
<A NAME="IDX6303"></A>
</B><DD>일반적인 이름이 <B>fs</B>인 서버 프로세스에 대해
예약된 프로세스 유형. 이 프로세스는 파일 서버, 볼륨 서버 및 구조 프로그램의
세 가지 구성요소를 조합한 것입니다.
<A NAME="IDX6304"></A>
<A NAME="IDX6305"></A>
<P><DT><B>cron
</B><DD>계속적이지 않으며 정의된 시간에 실행되는 프로세스. 이 유형을 가진
표준 프로세스는 없습니다.
</DL>
<A NAME="IDX6306"></A>
<A NAME="IDX6307"></A>
<A NAME="IDX6308"></A>
<A NAME="IDX6309"></A>
</LI><LI>그 상태 플래그는 BOS 서버가 프로세스와 관련하여 다음의 두 가지 작업을 수행하고
있는지 여부를 BOS 서버에 알려 줍니다.
<UL>
<LI>BOS 서버 초기설정 중에 프로세스 시작
</LI><LI>프로세스가 실패한 경우 프로세스 재시작
</LI></UL>
두 가지 가능한 값은 <TT>Run</TT>(BOS 서버에게 이들 작업을 수행하도록
지시) 및 <TT>NotRun</TT>(BOS 서버에게 프로세스를 무시하도록 지시)입니다.
BOS 서버 자체는 프로세스가 반복적으로 실패하는 경우에도 이 플래그의 상태를
절대 변경하지 않습니다. 또한 이 플래그는 내부 사용만을 목적으로 합니다.
따라서 <B>bos status</B> 명령의 출력에는 나타나지 않습니다.
</LI><LI>그 명령 매개변수는 BOS 서버가 프로세스를 시작하기 위해 실행하는
명령입니다.
<A NAME="IDX6310"></A>
<P>
<UL>
<LI>Simple 프로세스는 2진 파일에 대한 완전한 경로 이름인 하나의 매개변수를
가집니다.
</LI><LI><B>fs</B> 프로세스는 세 구성요소 구성요소 각각에 대한
완전한 경로 이름(<B>/usr/afs/bin/fileserver</B>, <B>/usr/afs/bin/volserver</B> 및 <B>/usr/afs/bin/salvager</B>)을 나타내는 세 가지 매개변수를 가집니다.
</LI><LI>cron 프로세스는 2진 파일에 대한 완전한 경로 이름과 BOS 서버가
실행되는 시간을 나타내는 두 가지 매개변수를 가집니다.
</LI></UL>
</LI></UL>
<P><B>BosConfig</B> 파일은 프로세스 정의와 함께 새 2진 파일을
포함하는 프로세스 및 BOS 서버를 포함하는 모든 서버 프로세스에 대한 자동
재시작 시간을 기록합니다. <A HREF="#HDRWQ171">BOS 서버의 재시작 시간 설정</A>을 참조하십시오.
<P><H3><A NAME="HDRWQ155" HREF="auagd002.htm#ToC_177">BOS 서버가 BosConfig 파일의 정보를 사용하는 방법</A></H3>
<A NAME="IDX6311"></A>
<A NAME="IDX6312"></A>
<A NAME="IDX6313"></A>
<P>BOS 서버는 시작되거나 재시작될 때마다 <B>BosConfig</B>
파일을 읽어 어떤 프로세스를 시작하여 모니터할지 확인합니다. 또한
그 정보를 커널 메모리에 전송하고 다음 재시작 때까지 <B>BosConfig</B> 파일을 다시 읽지 않습니다. 이것은 BOS 서버의 메모리 상태가
<B>BosConfig</B> 파일과는 독립적으로 변경될 수 있음을
의미합니다. 예를 들어 프로세스를 정지하고 <B>BosConfig</B>
파일에서 그 상태 플래그를 <TT>Run</TT>으로 남겨 두거나
<B>BosConfig</B> 파일에서 그 상태 플래그가 <TT>NotRun</TT>인
경우에도 프로세스를 시작할 수 있습니다.
<P><H3><A NAME="HDRWQ156" HREF="auagd002.htm#ToC_178">데이터베이스 서버 프로세스 시작 및 정지에 대하여</A></H3>
<A NAME="IDX6314"></A>
<A NAME="IDX6315"></A>
<A NAME="IDX6316"></A>
<A NAME="IDX6317"></A>
<A NAME="IDX6318"></A>
<A NAME="IDX6319"></A>
<A NAME="IDX6320"></A>
<P>잠깐 동안 데이터베이스 서버 프로세스(인증 서버, 백업 서버, 보호 서버 또는 볼륨
위치 서버)를 시작하거나 정지할 때 <I>AFS 빠른 시작</I>에서 데이터베이스 서버
시스템의 설치 또는 제거에 대한 지침을 따라야 합니다. 다음은 올바른 AFS
기능을 유지하기 위해 수행해야 하는 타스크에 대한 요약입니다.
<UL>
<LI>해당 시스템에서 네 가지의 모든 데이터베이스 서버 프로세스를 시작
또는 정지하십시오. 모든 AFS 서버 프로세스와 캐쉬 관리 프로그램은 네 가지
데이터베이스 서버 프로세스가 모두 <B>CellServDB</B> 파일에
나열된 각 시스템에서 실행될 것으로 기대합니다. 파일에 한 시스템에서
일부 데이터베이스 서버 프로세스만 실행되도록 지정하는 방법은 없습니다.
</LI><LI>모든 서버 시스템의 <B>/usr/afs/etc/CellServDB</B>
파일에서, 모든 클라이언트 시스템의 <B>/usr/vice/etc/CellServDB</B> 파일에서 시스템을 추가 또는 제거하십시오.
</LI><LI>다른 데이터베이스 서버 시스템의 데이터베이스 서버 프로세스를
재시작하여 강제로 각 시스템에 대한 Ubik 조정자를 새로 선택하게 하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ157" HREF="auagd002.htm#ToC_179">갱신 서버 시작 및 정지에 대하여</A></H3>
<A NAME="IDX6321"></A>
<P>일반적인 셀 구성에서 각 시스템 유형을 가진 하나의 서버 시스템은 2진 분산
시스템으로 작동되고 갱신 서버의 서버 부분(<B>upserver</B>
프로세스)를 실행하여 그 <B>/usr/afs/bin</B> 디렉토리의
내용을 분배합니다. 해당 시스템 유형을 가진 다른 서버 시스템은 2진 분산
시스템을 참조하는 갱신 서버 클라이언트 부분(일반적으로
<B>upclientbin</B>라고 함)의 인스턴스를 실행합니다.
<P>미국판 AFS를 실행하는 경우 설치하는 첫번째 서버 시스템이 시스템 제어
시스템으로 작동하는 것이 일반적이며 이 시스템은 갱신 서버의 서버
부분(<B>upserver</B> 프로세스)를 실행하여 그
<B>/usr/afs/etc</B> 디렉토리의 내용을 분배합니다.
다른 모든 서버 시스템은 시스템 제어 시스템을 참조하는 갱신 서버 클라이언트
부분(일반적으로 <B>upclientetc</B>라고 함)의 인스턴스를
실행합니다.
<P><TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">각국 언어판 AFS를 사용하는 경우 <B>/usr/afs/etc</B> 디렉토리의 내용을 분배하기 위해 갱신 서버를 사용하지
않도록 하십시오 (시스템 제어 시스템을 실행하지 않게 됨). 이 장에 나오는
프로세스에 대한 모든 참조를 무시하십시오.
</TD></TR></TABLE>
<P>현재 2진 분산 또는 시스템 제어 시스템의 역할 중 하나를 수행하고 있는
시스템을 완전히 중단하지 않는 한 이들 시스템의 책임을 다른 시스템으로
옮기지 않는 것이 간단합니다. 갱신 서버를 실행하면 보통 거의 처리 로드가
부과되지 않습니다. 기능을 이동해야만 하는 경우 다음의 관련 타스크를
수행하십시오.
<UL>
<LI>시스템 제어 시스템을 대체하는 경우 다른 모든 서버 시스템에서
<B>upclientetc</B> 프로세스를 중지하고 새 시스템 제어
시스템을 참조하는 새 프로세스를 정의해야 합니다.
</LI><LI>2진 분산 시스템을 대체하는 경우 해당 시스템 유형을 가진 다른 모든
서버 시스템에서 <B>upclientbin</B> 프로세스를 중지하고
새 2진 분산 시스템을 참조하는 새 프로세스를 정의해야 합니다 (해당 시스템
유형을 가진 서버 시스템을 실행하는 경우).
</LI></UL>
<HR><H2><A NAME="HDRWQ158" HREF="auagd002.htm#ToC_180">프로세스 상태와 BosConfig 파일의 정보 표시하기</A></H2>
<P>서버 시스템의 AFS 서버 프로세스의 상태를 표시하려면
<B>bos status</B> 명령을 실행하십시오. <B>-long</B> 플래그를 추가하면 그 유형 및 명령 매개변수를 포함하여
<B>BosConfig</B> 파일에 있는 각 프로세스 항목의
대부분의 정보가 표시됩니다. 또한 <B>/usr/afs</B>
디렉토리에 있는 파일 및 하위 디렉토리에 대한 모드 비트가 기대값과
일치하지 않을 경우 경고 메시지를 표시합니다.
<P><H3><A NAME="HDRWQ159" HREF="auagd002.htm#ToC_181">서버 프로세스의 상태와 BosConfig 항목을 표시하려면</A></H3>
<A NAME="IDX6322"></A>
<A NAME="IDX6323"></A>
<A NAME="IDX6324"></A>
<A NAME="IDX6325"></A>
<A NAME="IDX6326"></A>
<A NAME="IDX6327"></A>
<A NAME="IDX6328"></A>
<A NAME="IDX6329"></A>
<OL TYPE=1>
<LI><B>bos status</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos status</B> &lt;<VAR>machine&nbsp;name</VAR>>  [&lt;<VAR>server&nbsp;process&nbsp;name</VAR>><SUP>+</SUP>]  [<B>-long</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>stat
</B><DD>허용되는 <B>status</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>프로세스 상태를 표시할 파일 서버 시스템을 지정합니다.
<P><DT><B><VAR>server process name</VAR>
</B><DD><B>bos create</B> 명령으로 그 항목이 정의되었을 때
지정된 이름을 사용하여 상태를 표시할 각 프로세스를 명명합니다.
모든 서버 프로세스의 상태를 표시하려면 이 인수를 생략하십시오.
<P><DT><B>-long
</B><DD><B>BosConfig</B> 파일에 있는 프로세스 항목의
정보인 유형, 상태 플래그, 명령 매개변수, 연관된 지정자 프로그램 등과
상태를 표시합니다.
</DL>
</LI></OL>
<P>출력에는 각 프로세스에 대한 항목이 들어 있으며 다음 문자열 중 하나를
사용하여 프로세스의 상태를 나타냅니다.
<UL>
<LI><TT>currently running normally</TT>는 프로세스가 실행되고 있으며
<B>BosConfig</B> 파일의 상태 플래그가 <TT>Run</TT>임을
나타냅니다. cron 항목의 경우 이 메시지는 명령이 여전히 실행될 예정이지만
<B>bos status</B> 명령이 실행될 때 실제로 실행되고 있다고
확신할 수 없음을 나타냅니다.
</LI><LI><TT>temporarily enabled</TT>는 프로세스가 실행되고 있으나
<B>BosConfig</B> 파일의 상태 플래그가 <TT>NotRun</TT>임을 나타냅니다. 가장 일반적인 이유는 시스템 관리자가
<B>bos startup</B> 명령을 사용하여 프로세스를 시작한
경우입니다.
</LI><LI><TT>temporarily disabled</TT>는 <B>BosConfig</B>
파일의 상태 플래그가 <TT>Run</TT>인 경우에도 프로세스가 실행되고 있지
않음을 나타냅니다. 가장 일반적인 이유는 시스템 관리자가 <B>bos
shutdown</B> 명령을 사용하여 프로세스를 정지했거나 BOS 서버가 여러 번의
실패 시도 후에 프로세스의 재시작 시도를 중단한 것입니다. 두 번째 경우에는
다음과 같은 보충 메시지가 나타납니다. <TT>stopped for too many errors</TT>.
</LI><LI><TT>disabled</TT>는 프로세스가 실행되고 있지 않으며
<B>BosConfig</B> 파일의 상태 플래그가 <TT>NotRun</TT>인
경우를 나타냅니다. BOS 서버는 프로세스를 모니터하고 있지 않습니다.
시스템 관리자만 이러한 방식으로 플래그를 설정하지 BOS 서버는 이렇게 할 수
없습니다.
</LI></UL>
<P><B>fs</B> 프로세스의 출력에는 항상
<TT>Auxiliary status</TT>라고 표시된 메시지가 포함되며 이 메시지는 다음 중 하나가
될 수 있습니다.
<UL>
<LI><TT>file server running</TT>은 파일 서버 프로세서의 파일 서버와
볼륨 서버 구성요소가 정상적으로 실행되고 있음을 나타냅니다.
</LI><LI><TT>salvaging file system</TT>은 구조 프로그램이 실행되고 있으며
이것은 보통 파일 서버와 볼륨 서버가 일시적으로 사용 불가능 상태임을
의미합니다. BOS 서버는 구조 프로그램이 종료되자마자 이들 서버를 재시작합니다.
</LI></UL>
<P>cron 프로세스의 출력에는 명령이 다음에 실행되도록 예정되어 있을 때 보고할
<TT>Auxiliary status</TT> 메시지가 포함되어 있습니다. 다음 예제를
참조하십시오.
<P>프로세스의 출력에는 보충 메시지 <TT>has core file</TT>이 포함되어
있어 특정 시점에 프로세스가 실패했으며 <B>/usr/afs/logs</B>
디렉토리에 코어 파일이 생성되었음을 나타냅니다.
대부분의 경우에 BOS 서버는 프로세스를 재시작할 수 있으며 프로세스는
실행되고 있습니다.
<P>다음 예에는 <B>backupusers</B>라고 하는 사용자 정의
cron 항목이 들어 있습니다.
<PRE>   % <B>bos status fs3.example.com</B>
   Instance kaserver, currently running normally.
   Instance ptserver, currently running normally.
   Instance vlserver, has core file, currently running normally.
   Instance buserver, currently running normally.
   Instance fs, currently running normally.
     Auxiliary status is: file server running.
   Instance upserver, currently running normally.
   Instance runntp, currently running normally.
   Instance backupusers, currently running normally.
       Auxiliary status is: run next at Mon Jun 7 02:00:00 1999.
</PRE>
<P><B>bos status</B> 명령에 <B>-long</B>
플래그를 포함시키면 출력의 프로세스 항목에는 <B>BosConfig</B>
파일에서 가져온 다음의 추가 정보가 포함됩니다.
<UL>
<LI>프로세스 유형(<TT>simple</TT>, <TT>fs</TT> 또는 <TT>cron</TT>).
</LI><LI>프로세스가 마지막으로 시작되었거나 재시작된 날짜와 시간.
</LI><LI>BOS 서버가 프로세스를 시작했거나 재시작한 횟수를 나타내는
<TT>proc starts</TT>의 수.
</LI><LI>프로세스(또는 <B>fs</B> 프로세스에서 프로세스 구성요소
중 하나)가 마지막으로 종료된 <TT>최종 종료</TT> 시간. 이 행은
BOS 서버가 시작된 이후에 프로세스가 종료된 경우에는 나타나지 않습니다.
</LI><LI>프로세스(또는 <B>fs</B> 프로세스에서 프로세스 구성요소
중 하나)가 오류로 인해 마지막으로 실패한 <TT>최종 오류 종료</TT> 시간.
<TT>due to shutdown request</TT>와 같은 추가 설명이 나타나는 경우도
있습니다. 이 행은 BOS 서버가 시작된 이후에 프로세스가 실패하지 않았으면
나타나지 않습니다.
</LI><LI><B>bos create</B> 명령에 대해 <B>-cmd</B>
인수를 지정하는 것처럼 BOS 서버가 프로세스를 시작하기 위해 호출하는
각 명령.
</LI><LI><B>bos create</B> 명령에 대해 <B>-notifier</B> 인수를 지정하는 것처럼 프로세스가 중단되었을 때 BOS 서버가
호출하는 지정자 프로그램의 경로 이름.
</LI></UL>
<P>또한 BOS 서버가 <B>/usr/afs</B>에 있는 특정 파일 및
디렉토리에 대한 모드 비트가 예상한 값을 벗어나는 것을 발견하면
다음의 경고 메시지를 인쇄합니다.
<PRE>   Bosserver process reports inappropriate access on server directories
</PRE>
<P><B>/usr/afs</B> 디렉토리의 디렉토리와 파일에 대해 예상되는
보호 조치는 다음과 같습니다. 물음표는 BOS 서버가 모드 비트를 확인하지
않음을 나타냅니다. 이들 파일 및 디렉토리에 대한 보호 설정에 대한 자세한
정보를 보려면 <I>AFS 빠른 시작</I>을 참조하십시오.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwxr</TT>?<TT>xr-x</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/backup</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwx</TT>???<TT>---</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/bin</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwxr</TT>?<TT>xr-x</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/db</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwx</TT>???<TT>---</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/etc</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwxr</TT>?<TT>xr-x</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/etc/KeyFile</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>-rw</TT>????<TT>---</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/etc/UserList</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>-rw</TT>?????<TT>--</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/local</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwx</TT>???<TT>---</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>/usr/afs/logs</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>drwxr</TT>?<TT>xr-x</TT>
</TD></TR></TABLE>
<P>다음은 시스템 <B>fs3.example.com</B>에서 실행되는
<B>fs</B> 프로세스에 대한 확장된 출력 결과를 보여 줍니다.
<PRE>   % <B>bos status fs3.example.com fs -long</B>
   Instance fs, (type is fs), currently running normally.
       Auxiliary status is file server running
   Process last started at Mon May 3 8:29:19 1999 (3 proc starts)
   Last exit at Mon May 3 8:29:19 1999
   Last error exit at Mon May 3 8:29:19 1999, due to shutdown request
     Command 1 is '/usr/afs/bin/fileserver'
     Command 2 is '/usr/afs/bin/volserver'
     Command 3 is '/usr/afs/bin/salvager'
</PRE>
<HR><H2><A NAME="HDRWQ161" HREF="auagd002.htm#ToC_182">프로세스 작성 및 제거</A></H2>
<A NAME="IDX6330"></A>
<A NAME="IDX6331"></A>
<A NAME="IDX6332"></A>
<A NAME="IDX6333"></A>
<A NAME="IDX6334"></A>
<A NAME="IDX6335"></A>
<A NAME="IDX6336"></A>
<A NAME="IDX6337"></A>
<P>서버 시스템에서 새 AFS 서버 프로세스를 시작하려면 <B>bos create</B> 명령을 실행하십시오. 이 명령은 <B>/usr/afs/local/BosConfig</B> 파일에 항목을 작성하고, 이 파일과 BOS 서버의 메모리에서 프로세스의
상태 플래그를 모두 <TT>Run</TT>으로 설정하고, 즉시 프로세스를 실행합니다.
새 프로세스에 대한 2진 파일은 보통 <B>/usr/afs/bin</B>
디렉토리에 미리 설치되어 있어야 합니다(<A HREF="auagd008.htm#HDRWQ111">새 2진 파일 설치</A> 참고).
<P>프로세스를 영구히 정지하려면 먼저 <B>bos stop</B> 명령을 실행하십시오. 이 명령은 <B>BosConfig</B>
파일과 BOS 서버의 메모리에서 프로세스의 상태 플래그를 <TT>NotRun</TT>으로
설정합니다. 이 상태 플래그는 <B>bos status</B> 명령의
출력에는 <TT>disabled</TT>로 표시되어 있습니다. 원하는 경우
<B>bos delete</B> 명령을 실행하여 <B>BosConfig</B> 파일에서 프로세스의 항목을 제거하십시오. 그러면 이 프로세스는
더 이상 <B>bos status</B> 명령의 출력에 나타나지 않습니다.
<P><TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 절에서 설명하는 방식대로 데이터베이스 서버 프로세스를 시작하거나
정지하는 경우 <I>AFS 빠른 시작</I>에서 데이터베이스 서버 시스템 작성 또는 제거에
대한 자세한 지침을 참조하십시오. 주어진 시스템에서 하나의 데이터베이스
서버 프로세스를 실행하는 경우 이들을 모두 실행해야 합니다.
자세한 정보를 보려면 <A HREF="#HDRWQ156">데이터베이스 서버 프로세스 시작 및 정지에 대하여</A>를 참조하십시오. 이와
마찬가지로 시스템 제어 시스템이나 분산 2진 시스템에서 <B>upserver</B>
프로세스를 정지하는 경우 <A HREF="#HDRWQ157">갱신 서버 시작 및 정지에 대하여</A>에서 설명하는
추가 타스크를 완료해야 합니다.
</TD></TR></TABLE>
<P><H3><A NAME="HDRWQ162" HREF="auagd002.htm#ToC_183">새 프로세스를 작성 및 시작하려면</A></H3>
<A NAME="IDX6338"></A>
<A NAME="IDX6339"></A>
<A NAME="IDX6340"></A>
<A NAME="IDX6341"></A>
<A NAME="IDX6342"></A>
<A NAME="IDX6343"></A>
<A NAME="IDX6344"></A>
<A NAME="IDX6345"></A>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 인증된 사용자로
나열되어 있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>(선택적)</B> 프로세스의 2진 파일이 이 시스템의
<B>/usr/afs/bin</B> 디렉토리에 설치되어 있는지 확인하십시오.
필요하면 콘솔에 로그인하거나 시스템으로 telnet하고
<B>/usr/afs/bin</B> 디렉토리의 내용을 나열하십시오.
<P>
<P>2진 파일이 없으면 적절한 시스템 유형의 분산 2진 시스템에 이들 2진
파일을 설치하고 갱신 서버가 이들 파일을 이 시스템에 복사할 때까지
기다리십시오.
지침을 보려면 <A HREF="auagd008.htm#HDRWQ111">새 2진 파일 설치</A>를 참조하십시오.
<P>
<PRE>   %
<B>ls /usr/afs/bin</B>
</PRE>
</LI><LI><A NAME="LIWQ163"></A><B>bos create</B> 명령을 실행하여
<B>BosConfig</B> 파일에 항목을 작성하고 프로세스를
시작하십시오.
<P>
<PRE>   % <B>bos create</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>server&nbsp;process&nbsp;name</VAR>>   \
             &lt;<VAR>server&nbsp;type</VAR>>
&lt;<VAR>command&nbsp;lines</VAR>><SUP>+</SUP> [ <B>-notifier</B> &lt;<VAR>Notifier&nbsp;program</VAR>>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>cr
</B><DD>허용되는 <B>create</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>프로세스를 작성할 파일 서버 시스템을 지정합니다.
<P><DT><B><VAR>server process name</VAR>
</B><DD>작성 및 시작할 프로세스를 명명합니다. 단순 프로세스의 경우
일반적인 값은 프로세스 2진 파일의 이름입니다. 해당 프로세스를 실행하는
모든 서버 시스템에서 동일한 이름을 사용하는 것이 가장 좋습니다. 다음은
단순 및 fs 유형 프로세스에 대한 일반적인 이름 목록입니다(표준 cron
프로세스는 없음).
<UL>
<LI><B>buserver</B> 백업 서버에 대해
</LI><LI><B>fs</B> 파일 서버, 볼륨 서버 및 구조 프로그램을 조합하는 프로세스에 대해
</LI><LI><B>kaserver</B> 인증 서버에 대해
</LI><LI><B>ptserver</B> 보호 서버에 대해
</LI><LI><B>runntp</B> NTPD(Network Time Protocol Daemon)의 제어기 프로세스에 대해
</LI><LI><B>upclientbin</B> 이 시스템의 시스템 유형을 가진 2진 분산 시스템을 참조하는
갱신 서버의 클라이언트 부분에 대해
</LI><LI><B>upclientetc</B> 시스템 제어 시스템을 참조하는 갱신 서버의
클라이언트 부분에 대해
</LI><LI><B>vlserver</B> 볼륨 위치(VL) 서버에 대해
</LI></UL>
<P><DT><B><VAR>server type</VAR>
</B><DD>프로세스의 유형을 정의합니다. 다음 값 중 하나를 선택하십시오.
<UL>
<LI><B>cron</B> 크론 프로세스에 대해
</LI><LI><B>fs</B> <B>fs</B>라고 명명된 프로세스에 대해
</LI><LI><B>simple</B> <VAR>server&nbsp;process&nbsp;name</VAR> 인수에 대해 허용되는 값으로
나열된 다른 프로세스에 대해
</LI></UL>
<P><DT><B><VAR>command lines</VAR>
</B><DD>BOS 서버가 프로세스를 시작하기 위해 실행하는 각 명령을 지정합니다. 명령은
여섯 개까지 지정하십시오(여기에는 명령 옵션이 포함될 수 있으며 이 경우
전체 문자열은 큰 따옴표로 묶임). 추가 명령은 모두 무시됩니다.
<P>
<P>Simple 프로세스의 경우 로컬 디스크에 잇는 프로세스 2진 파일의 전체
경로 이름을 제공하십시오(예: 보호 서버의 경우
<B>/usr/afs/bin/ptserver</B>). 초기화 명령 옵션을
포함시키는 경우에는 전체 명령을 큰 따옴표(<B>" "</B>)로
묶으십시오. <B>upclient</B> 프로세스는 필수 인수를 가지며
다른 모든 프로세스에 대한 명령은 선택적 인수를 취합니다.
<A NAME="IDX6346"></A>
<P>
<P>
<P><B>fs</B> 프로세스의 경우 <B>fileserver</B>, <B>volserver</B>
및 <B>salvager</B>의 순서대로 각 구성요소 프로세스에 대해
로컬 디스크 2진 파일의 완전한 경로 이름을 제공하십시오. 표준 2진
디렉토리는 <B>/usr/afs/bin</B>입니다. 초기설정 명령의 옵션을
포함시키는 경우 전체 명령을 큰 따옴표(<B>" "</B>)로
묶으십시오.
<A NAME="IDX6347"></A>
<P>
<P>
<P><B>cron</B> 프로세스의 경우 다음의 두 매개변수를 제공하십시오.
<A NAME="IDX6348"></A>
<P>
<UL>
<LI>AFS 집합 중 하나로부터 가져온 실행 파일이나 명령의 완전한 로컬
디스크 경로 이름(필요한 모든 인수 포함). 공백이 있는 경우 이 매개변수를
큰 따옴표(<B>" "</B>)로 묶으십시오.
</LI><LI>BOS 첫째 매개변수에서 지정하는 파일이나 명령을 실행할 때의 스펙.
허용할 수 있는 값에는 다음의 세 가지가 있습니다.
<UL>
<LI>문자열 <B>now</B>. 이것은 BOS 서버에게 파일이나 명령을
즉시 그리고 한 번만 실행하도록 지시합니다. 대개 해당 명령을 직접 실행하거나
<B>bos exec</B> 명령을 실행하는 것이 더 쉽습니다.
</LI><LI>하루 중 시간. BOS 서버는 지정된 시간에 파일이나 명령을 매일 실행합니다.
시간과 분은 콜론(<I>hh</I>:<I>MM</I>)으로
분리하고 24시간 형식이나 <B>1:00</B>에서
<B>12:59</B>까지의 값에 <B>am</B> 또는
<B>pm</B>을 추가하여 사용하십시오. 예를 들어
<B>14:30</B>과 <B>"2:30 pm"</B>은 모두 오후 2시 30분을 나타냅니다. 이 매개변수에 공백이
들어 있는 경우 큰 따옴표(<B>" "</B>)로 묶으십시오.
</LI><LI>요일과 시간. 공백으로 구분되고 큰 따옴표(<B>" "</B>)로
묶입니다. BOS 서버는 지정된 요일과 시간에 매주 파일이나 명령을 실행합니다.
요일의 경우 전체 이름이나 처음 세 문자를 모두 소문자로
제공하십시오(<B>sunday</B> 또는 <B>sun</B>, <B>thursday</B> 또는 <B>thu</B> 등). 시간의 경우 시간만
지정했을 때와 동일한 형식을 사용하십시오.
</LI></UL>
</LI></UL>
<P><DT><B>-notifier
</B><DD>프로세스가 종료될 때 BOS 서버가 실행하는 프로그램의 경로 이름을
지정합니다. 지정자 프로그램에 대한 자세한 정보를 보려면 <I>AFS Administration Reference</I>에서
<B>bos create</B> 명령 참조 페이지를 참조하십시오.
</DL>
</LI></OL>
<P>다음 예제는 시스템 <B>db2.example.com</B>의 보호 서버를 정의하고
시작합니다.
<PRE>
   % <B>bos create db2.example.com ptserver simple /usr/afs/bin/ptserver</B>

</PRE>
<P>다음 예제는 시스템 <B>fs6.example.com</B>의
<B>fs</B> 프로세스를 정의하고 시작합니다.
<PRE>
   % <B>bos create fs6.example.com fs fs /usr/afs/bin/fileserver </B>  \
        <B>/usr/afs/bin/volserver /usr/afs/bin/salvager</B>

</PRE>
<P>다음 예제는 시스템 <B>fs3.example.com</B>에서
<B>backupuser</B> 프로세스라고 하는 cron 프로세스를
정의하고 시작합니다. 이 프로세스는 매일 새벽 3시에 실행되도록 예정되어
있습니다.
<PRE>   % <B>bos create fs3.example.com backupuser cron  "/usr/afs/bin/vos backupsys -prefix user -local" 3:00</B>
</PRE>
<P><H3><A NAME="Header_184" HREF="auagd002.htm#ToC_184">프로세스를 정지하고 BosConfig 파일에서 제거하려면</A></H3>
<A NAME="IDX6349"></A>
<A NAME="IDX6350"></A>
<A NAME="IDX6351"></A>
<A NAME="IDX6352"></A>
<A NAME="IDX6353"></A>
<A NAME="IDX6354"></A>
<A NAME="IDX6355"></A>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 인증된 사용자로
나열되어 있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><A NAME="LIPROC-STOP"></A><B>bos stop</B> 명령을 실행하여
<B>BosConfig</B> 파일의 각 프로세스 상태 플래그를 <TT>NotRun</TT>로 변경하고 중지하십시오. <B>BosConfig</B>
파일에서 제거하려는 cron 프로세스가 연속적으로 실행되고 있지 않은 경우에도
이 프로세스에 대해 이 명령을 실행해야 합니다. 이 명령에 대한 자세한 설명을
보려면 <A HREF="#HDRWQ165">상태를 NotRun으로 변경하여 프로세스를 정지하려면</A>을 참조하십시오.
<P>
<PRE>
   % <B>bos stop</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>server&nbsp;process&nbsp;name</VAR>><SUP>+</SUP> [<B>-wait</B>]

</PRE>
</LI><LI><A NAME="LIPROC-DEL"></A><B>bos delete</B> 명령을 실행하여
<B>BosConfig</B> 파일에서 각 프로세스를 제거하십시오.
<P>
<PRE>   %
<B>bos delete</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>server&nbsp;process&nbsp;name</VAR>><SUP>+</SUP>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>d
</B><DD>허용되는 <B>delete</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD><B>BosConfig</B> 파일에서 프로세스를 제거할 서버
시스템을 지정합니다.
<P><DT><B><VAR>server process name</VAR>
</B><DD><B>BosConfig</B> 파일에서 제거할 각 프로세스 항목을
명명합니다. 단계 <A HREF="#LIPROC-STOP">2</A>에서와 동일한 이름을 제공하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ164" HREF="auagd002.htm#ToC_185">프로세스 영구 정지 및 시작</A></H2>
<A NAME="IDX6356"></A>
<A NAME="IDX6357"></A>
<A NAME="IDX6358"></A>
<A NAME="IDX6359"></A>
<P>BOS 서버가 더 이상 모니터하려고 시도하지 않도록 프로세스를 정지하려면
<B>bos stop</B> 명령을 실행하십시오. 프로세스의 상태
플래그는 BOS 서버의 메모리와 <B>BosConfig</B> 파일 모두에서
<TT>NotRun</TT>으로 설정됩니다. 프로세스는 사용자가 그 상태 플래그를
BOS 서버의 메모리와 <B>BosConfig</B> 파일 모두에서
<TT>Run</TT>으로 설정하는 <B>bos start</B> 명령을 실행할
때까지 다시 실행되지 않습니다(또한 <B>BosConfig</B> 파일에서
상태 플래그를 변경하지 않고도 <B>bos startup</B> 명령을
사용하여 프로세스를 다시 시작할 수 있습니다. <A HREF="#HDRWQ167">프로세스 일시 정지 및 시작</A>을
참조하십시오).
<P><B>BosConfig</B> 파일에 BOS 서버에 대한 항목이 없으면
<B>bos stop</B> 및 <B>bos start</B> 명령이
BOS 서버를 제어하지 않습니다. 다른 모든 프로세스와 함께 BOS 서버를 정지한 후
즉시 재시작하려면 <A HREF="#HDRWQ170">프로세스를 정지한 후 즉시 재시작하기</A>에서 설명하는 것처럼
<B>bos restart</B> 명령에 대해 <B>-bosserver</B>
플래그를 사용하십시오.
<P><TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 절에서 설명하는 방식대로 데이터베이스 서버 프로세스를 시작하거나
정지하는 경우 <I>AFS 빠른 시작</I>에서 데이터베이스 서버 시스템 작성 또는 제거에
대한 자세한 지침을 참조하십시오. 주어진 시스템에서 하나의 데이터베이스
서버 프로세스를 실행하는 경우 이들을 모두 실행해야 합니다.
자세한 정보를 보려면 <A HREF="#HDRWQ156">데이터베이스 서버 프로세스 시작 및 정지에 대하여</A>를 참조하십시오. 이와
마찬가지로 시스템 제어 시스템이나 분산 2진 시스템에서 <B>upserver</B>
프로세스를 정지하는 경우 <A HREF="#HDRWQ157">갱신 서버 시작 및 정지에 대하여</A>에서 설명하는
추가 타스크를 완료해야 합니다.
</TD></TR></TABLE>
<P><H3><A NAME="HDRWQ165" HREF="auagd002.htm#ToC_186">상태를 NotRun으로 변경하여 프로세스를 정지하려면</A></H3>
<A NAME="IDX6360"></A>
<A NAME="IDX6361"></A>
<A NAME="IDX6362"></A>
<A NAME="IDX6363"></A>
<A NAME="IDX6364"></A>
<A NAME="IDX6365"></A>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 인증된 사용자로
나열되어 있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos stop</B> 명령을 실행하여 각 프로세스를 정지하고
<B>BosConfig</B> 파일과 BOS 서버의 메모리에서 그 상태
플래그를 <TT>NotRun</TT>으로 설정하십시오.
<P>
<PRE>   % <B>bos stop</B> &lt;<VAR>machine&nbsp;name</VAR>>
&lt;<VAR>server&nbsp;process&nbsp;name</VAR>><SUP>+</SUP> [<B>-wait</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sto
</B><DD>허용되는 <B>stop</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>프로세스를 정지할 서버 시스템을 지정합니다.
<P><DT><B><VAR>server process name</VAR>
</B><DD><B>bos create</B> 명령으로 그 항목이 정의되었을 때
지정된 이름을 사용하여 정지할 각 프로세스를 명명합니다.
<P><DT><B>-wait
</B><DD>지정된 모든 프로세스가 정지될 때까지 명령 쉘 프롬프트의 리턴을
지연합니다. 이 플래그를 생략하면 모든 프로세스가 아직 정지되지 않은
경우에도 프롬프트가 바로 나타납니다.
</DL>
</LI></OL>
<P><H3><A NAME="HDRWQ166" HREF="auagd002.htm#ToC_187">상태 플래그를 Run으로 변경하여 프로세스를 시작하려면</A></H3>
<A NAME="IDX6366"></A>
<A NAME="IDX6367"></A>
<A NAME="IDX6368"></A>
<A NAME="IDX6369"></A>
<A NAME="IDX6370"></A>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><A NAME="LIPROC-START"></A><B>bos start</B> 명령을 실행하여
<B>BosConfig</B> 파일과 BOS 서버의 메모리에서 각 프로세스의
상태 플래그를 <TT>Run</TT>으로 변경하고 시작하십시오.
<P>
<PRE>   %
<B>bos start</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>server&nbsp;process&nbsp;name</VAR>><SUP>+</SUP>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>start
</B><DD>전체를 입력해야 합니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>각 프로세스의 실행을 시작할 서버 시스템을 지정합니다.
<P><DT><B><VAR>server process name</VAR>
</B><DD><VAR>machine name</VAR>에서 시작할 각 프로세스를 지정합니다. 작성시에
해당 프로세스에 지정된 이름을 사용하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ167" HREF="auagd002.htm#ToC_188">프로세스 일시 정지 및 시작</A></H2>
<P>때때로 프로세스를 일시적으로 중단해야 하는 경우가 있습니다(예를 들어
구성을 약간 변경하거나 유지 관리를 수행할 때). 이 절에서 설명하는 명령은
BOS 서버의 메모리에서만 프로세스의 상태를 변경합니다. 그 효과는 즉각적이며
사용자가 메모리 상태를 다시 변경할 때까지 지속됩니다(또는 BOS 서버가
<B>BosConfig</B> 파일의 항목에 따라 프로세스를 시작하는
BOS 서버 재시작 시간까지).
<P>BOS 서버 메모리에서 그 상태 플래그를 <TT>NotRun</TT>으로 변경하여
프로세스를 일시적으로 정지하려면 <B>bos shutdown</B> 명령을
사용하십시오.
BOS 서버 메모리에서 그 상태 플래그를 <TT>Run</TT>으로 변경하여 정지된
프로세스를 재시작하려면 <B>bos startup</B> 명령을 사용하십시오.
프로세스는 <B>BosConfig</B> 파일의 상태 플래그에 관계없이
시작됩니다. 또한 다음에서 설명하는 것처럼 <B>bos startup</B>
명령을 사용하여 <B>BosConfig</B> 파일에서 상태 플래그가
<TT>Run</TT>으로 표시된 모든 프로세스를 시작할 수도 있습니다.
<P><B>bos startup</B> 명령은 <B>BosConfig</B>
파일에서 프로세스의 상태 플래그를 변경하지 않은 채로 프로세스를 시작하므로
프로세스를 영구히 사용 가능하게 하지 않고 검사하는 데 유용합니다.
<B>BosConfig</B> 파일에서 그 상태 플래그를 변경하여
프로세스를 정지 및 시작하려면 <A HREF="#HDRWQ164">프로세스 영구 정지 및 시작</A>을
참조하십시오. 프로세스를 정지했다가 즉시 재시작하려면
<A HREF="#HDRWQ170">프로세스를 정지한 후 즉시 재시작하기</A>를 참조하십시오.
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">모든 시스템의 데이터베이스 서버 프로세스를 한 번에 일시적으로
정지하지 마십시오. 이렇게 하면 데이터베이스를 완전히 사용하지 못하게 될 수
있습니다.
</TD></TR></TABLE>
<A NAME="IDX6371"></A>
<A NAME="IDX6372"></A>
<P><H3><A NAME="HDRWQ168" HREF="auagd002.htm#ToC_189">프로세스를 일시적으로 정지하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><A NAME="LIWQ169"></A><B>bos shutdown</B> 명령을 실행하여
BOS 서버의 메모리에서 프로세스의 상태 플래그를 <TT>NotRun</TT>으로
변경함으로써 각 프로세스를 정지하십시오.
<P>
<PRE>   % <B>bos shutdown</B> &lt;<VAR>machine&nbsp;name</VAR>> [&lt;<VAR>instances</VAR>><SUP>+</SUP>]
[<B>-wait</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>sh
</B><DD>허용되는 <B>shutdown</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>일시적으로 프로세스를 정지한 서버 시스템을 지정합니다.
<P><DT><B><VAR>instances</VAR>
</B><DD>일시적으로 정지할 각 프로세스를 지정합니다. 작성
시에 해당 프로세스에 지정된 이름을 사용하십시오.
<P><DT><B>-wait
</B><DD>지정된 모든 프로세스가 실제로 정지될 때까지 명령 쉘 프롬프트의 리턴을
지연합니다. 이 플래그를 생략하면 모든 프로세스가 아직 정지되지 않은
경우에도 프롬프트가 바로 나타납니다.
</DL>
</LI></OL>
<A NAME="IDX6373"></A>
<A NAME="IDX6374"></A>
<P><H3><A NAME="Header_190" HREF="auagd002.htm#ToC_190">BosConfig 파일에 상태 플래그가 Run으로 설정된 정지된 모든 프로세스를 시작하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos startup</B> 명령을 실행하여 BOS 서버 메모리의
상태 플래그를 <TT>NotRun</TT>에서 <TT>Run</TT>으로 변경함으로써
<B>BosConfig</B> 파일에서 상태 플래그가 <TT>Run</TT>으로
설정된 시스템의 각 프로세스를 시작하십시오.
<P>
<PRE>   % <B>bos startup</B> &lt;<VAR>machine&nbsp;name</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>startup
</B><DD>전체를 입력해야 합니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD><B>BosConfig</B> 파일에 상태 플래그가 <TT>Run</TT>으로
설정된 모든 프로세스를 시작하려는 서버 시스템을 지정합니다.
</DL>
</LI></OL>
<P><H3><A NAME="Header_191" HREF="auagd002.htm#ToC_191">특정 프로세스를 시작하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos startup</B> 명령을 실행하여 <B>BosConfig</B> 파일에서 상태 플래그를 변경하지 않고 BOS 서버의 메모리에서
상태 플래그를 <TT>Run</TT>으로 변경하여 특정 프로세스를 시작하십시오.
<P>
<PRE>   % <B>bos startup</B> &lt;<VAR>machine&nbsp;name</VAR>> &lt;<VAR>instances</VAR>><SUP>+</SUP>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>startup
</B><DD>전체를 입력해야 합니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>프로세스를 시작할 서버 시스템을 명명합니다.
<P><DT><B><VAR>instances</VAR>
</B><DD>시작할 각 프로세스를 지정합니다. 작성 시에 해당 프로세스에
지정된 이름을 사용하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ170" HREF="auagd002.htm#ToC_192">프로세스를 정지한 후 즉시 재시작하기</A></H2>
<A NAME="IDX6375"></A>
<A NAME="IDX6376"></A>
<P>기본적으로 BOS 서버가 매일 새로 설치된 2진 파일을 확인하고 연관된
프로세스를 재시작한다고 해도 때때로 프로세스를 정지했다가 즉시 재시작해야
하는 경우가 있습니다. <B>bos restart</B> 명령은
이 기능을 제공하여 영향 받는 각 프로세스의 완전히 새로운 인스턴스를
시작합니다.
<UL>
<LI>BOS 서버를 정지했다가 재시작한 다음 <B>BosConfig</B> 파일에서 <TT>Run</TT> 상태 플래그로 표시된 모든 프로세스를
재시작하려면 <B>-bosserver</B> 플래그를 포함시키십시오.
</LI><LI><B>BosConfig</B> 파일에서 <TT>Run</TT> 상태 플래그가
설정된 모든 프로세스를 정지했다가 재시작하려면 <B>BosConfig</B> file, include the <B>-all</B> 플래그를 포함시키십시오. BOS 서버는 재시작되지 않습니다.
</LI><LI><B>BosConfig</B> 파일의 상태 플래그 설정에 관계 없이
특정 프로세스를 정지했다가 재시작하려면 재시작할 각 프로세스의 이름을
지정하십시오.
</LI></UL>
<P>프로세스를 재시작하면 서비스 작동 중단 상태가 발생합니다. 보통 시스템이
별로 사용되고 있지 않을 때 재시작하도록 계획하는 것이 가장 바람직합니다.
BOS 서버는 일주일에 한 번 모든 프로세스를 자동으로 재시작하여 확장된
시간 동안 프로세스가 실행될 때 발생할 수 있는 중요한 누출 가능성을
줄입니다. <A HREF="#HDRWQ171">BOS 서버의 재시작 시간 설정</A>을 참조하십시오.
<A NAME="IDX6377"></A>
<A NAME="IDX6378"></A>
<P>
<A NAME="IDX6379"></A>
<A NAME="IDX6380"></A>
<A NAME="IDX6381"></A>
<A NAME="IDX6382"></A>
<A NAME="IDX6383"></A>
<P><H3><A NAME="Header_193" HREF="auagd002.htm#ToC_193">BOS 서버를 포함하는 모든 프로세스를 정지한 후 재시작하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>-bosserver</B> 플래그와 함께 <B>bos restart</B>
명령을 실행하여 BOS 서버를 정지했다가 재시작하십시오. 이렇게 하면
<B>BosConfig</B> 파일에서 상태 플래그가 <TT>Run</TT>으로
표시된 모든 프로세스가 재시작됩니다.
<P>
<PRE>   % <B>bos restart</B> &lt;<VAR>machine&nbsp;name</VAR>>  <B>-bosserver</B>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD>허용되는 <B>restart</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>모든 프로세스를 재시작할 서버 시스템을 지정합니다.
<P><DT><B>-bosserver
</B><DD>BOS 서버와 시스템에서 실행 중인 모든 프로세스를 정지합니다. 또한
새로운 BOS 서버 인스턴스가 시작되고 <B>BosConfig</B>
파일에서 상태 플래그가 <TT>Run</TT>으로 설정된 모든 프로세스의 새
인스턴스를 시작합니다.
</DL>
</LI></OL>
<A NAME="IDX6384"></A>
<A NAME="IDX6385"></A>
<A NAME="IDX6386"></A>
<A NAME="IDX6387"></A>
<P><H3><A NAME="Header_194" HREF="auagd002.htm#ToC_194">BOS 서버를 제외한 모든 프로세스를 정지한 후 즉시 재시작하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>-all</B> 플래그와 함께 <B>bos restart</B>
명령을 실행하여 <B>BosConfig</B> 파일에서 상태 플래그가
<TT>Run</TT>으로 설정된 모든 프로세스를 정지했다가 즉시 재시작하십시오.
BOS 서버는 재시작되지 않습니다.
<P>
<PRE>   % <B>bos restart</B> &lt;<VAR>machine&nbsp;name</VAR>> <B>-all</B>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD>허용되는 <B>restart</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>프로세스를 정지했다가 재시작할 서버 시스템을 지정합니다.
<P><DT><B>-all
</B><DD><B>BosConfig</B> 파일에서 상태 플래그가 <TT>Run</TT>으로 설정된 모든 프로세스를 정지했다가 즉시 재시작합니다.
</DL>
</LI></OL>
<A NAME="IDX6388"></A>
<A NAME="IDX6389"></A>
<A NAME="IDX6390"></A>
<A NAME="IDX6391"></A>
<P><H3><A NAME="Header_195" HREF="auagd002.htm#ToC_195">특정 프로세스를 정지한 후 즉시 재시작하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos restart</B> 명령을 실행하여 <B>BosConfig</B>
파일에 설정된 상태 플래그에 관계없이 지정된 하나 이상의 프로세스를
정지했다가 즉시 재시작하십시오.
<P>
<PRE>   % <B>bos restart</B> &lt;<VAR>machine&nbsp;name</VAR>>
&lt;<VAR>instances</VAR>><SUP>+</SUP>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>res
</B><DD>허용되는 <B>restart</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>지정된 프로세스를 재시작할 서버 시스템을 지정합니다.
<P><DT><B><VAR>instances</VAR>
</B><DD>정지했다가 즉시 재시작할 각 프로세스를 지정합니다. 작성시에 해당 프로세스에
지정된 이름을 사용하십시오.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ171" HREF="auagd002.htm#ToC_196">BOS 서버의 재시작 시간 설정</A></H2>
<A NAME="IDX6392"></A>
<A NAME="IDX6393"></A>
<A NAME="IDX6394"></A>
<A NAME="IDX6395"></A>
<A NAME="IDX6396"></A>
<A NAME="IDX6397"></A>
<A NAME="IDX6398"></A>
<A NAME="IDX6399"></A>
<A NAME="IDX6400"></A>
<P>기본적으로 BOS 서버는 한 주에 한 번 재시작하고 새 인스턴스는 로컬
<B>/usr/afs/local/BosConfig</B> 파일에서 상태 플래그가
<TT>Run</TT>으로 설정된 모든 프로세스를 재시작합니다(이것은
<B>-bosserver</B> 플래그를 사용하여
<B>bos restart</B> 명령을 실행하는 것과 동일함).
기본 재시작 시간은 일요일 새벽 3시입니다. 주별 재시작은 <I>중요한 누출</I>을 최소화하도록 디자인됩니다. 중요한 누출 상태는
프로세스가 계속 가상 메모리를 할당하지만 다시 사용 가능 상태로 만들지
않는 경우로 발전할 수 있습니다.
메모리가 완전히 고갈될 때 시스템은 더 이상 제대로 기능하지 못합니다.
<P>또한 BOS 서버는 기본적으로 새로 설치한 2진 파일을 하루에 한 번 확인합니다.
<B>/usr/afs/bin</B> 디렉토리의 프로세스 2진 파일에 있는
수정 시간 소인이 프로세스가 마지막으로 시작된 시간보다 더 최근이라는 사실이
발견되면 새 인스턴스가 새로운 2진 파일을 사용하도록 프로세스를
재시작합니다. 기본 2진 파일 확인 시간은 새벽 5시입니다.
<P>재시작을 수행할 경우 파일 시스템이 액세스할 수 없는 동안 작동 중지 상태가
발생할 수 있으므로 기본 재시작 시간은 사용도가 가장 낮을 것으로 예상되는
이른 아침 시간입니다. 데이터베이스 서버 시스템에서 데이터베이스 서버
프로세스를 재시작하면 보통 짧은 시간 동안 모든 사람이 전체 시스템을
사용할 수 없게 되지만 다른 유형의 프로세스를 재시작하면 해당 시스템의
해당 프로세스와 상호 작용하는 사용자만 편리함을 겪게 됩니다. 가장 긴
작동 중단 상태는 보통 파일 서버가 모든 볼륨을 재접속하게 되는
<B>fs</B> 프로세스 재시작의 경우가 됩니다.
<A NAME="IDX6401"></A>
<A NAME="IDX6402"></A>
<A NAME="IDX6403"></A>
<P>각 파일 서버 시스템의 <B>BosConfig</B> 파일은 두 번의
재시작 시간을 기록합니다. 현재 설정을 표시하려면 <B>bos getrestart</B> 명령을 실행하십시오. 시간을 재설정하려면 <B>bos
setrestart</B> 명령을 사용하십시오.
<A NAME="IDX6404"></A>
<A NAME="IDX6405"></A>
<A NAME="IDX6406"></A>
<P><H3><A NAME="Header_197" HREF="auagd002.htm#ToC_197">BOS 서버 재시작 시간을 표시하려면</A></H3>
<OL TYPE=1>
<LI><B>bos getrestart</B> 명령을 실행하여 자동 재시작
시간을 표시하십시오.
<P>
<PRE>   % <B>bos getrestart</B> &lt;<VAR>machine&nbsp;name</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>getr
</B><DD>허용되는 <B>getrestart</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>재시작 시간을 표시할 서버 시스템을 지정합니다.
</DL>
</LI></OL>
<A NAME="IDX6407"></A>
<A NAME="IDX6408"></A>
<A NAME="IDX6409"></A>
<P><H3><A NAME="HDRWQ172" HREF="auagd002.htm#ToC_198">일반 또는 2진 재시작 시간을 설정하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>-general</B> 플래그와 함께 <B>bos setrestart</B>
명령을 실행하여 일반 재시작 시간을 설정하거나 <B>-newbinary</B> 플래그를 사용하여 2진 재시작 시간을 설정하십시오.
이 명령은 한 번에 하나의 플래그만 허용합니다.
<P>
<PRE>   % <B>bos setrestart</B> &lt;<VAR>machine&nbsp;name</VAR>> "&lt;<VAR>time&nbsp;to&nbsp;restart&nbsp;server</VAR>>"
[<B>-general</B>]  [<B>-newbinary</B>]
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>setr
</B><DD>허용되는 <B>setrestart</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>서버 시스템을 지정합니다.
<P><DT><B><VAR>time to restart server</VAR>
</B><DD>BOS 서버가 자신이나(<B>-general</B> 플래그와 함께 사용)
새 2진 파일이 있는 프로세스(<B>-newbinary</B> 플래그와
함께 사용)를 재시작할 때 설정됩니다. 다음 유형의 값 중 하나를 제공하십시오.
<UL>
<LI>문자열 <B>never</B>. BOS 서버에게 지정된 재시작 유형을
수행하도록 지시합니다.
</LI><LI>시간(2진 재시작 시간에 대한 일반적인 값 유형)
시간과 분은 콜론(<I>hh</I>:<I>MM</I>)으로
분리하고 24시간 형식이나 <B>1:00</B>에서
<B>12:59</B>까지의 값에 <B>am</B> 또는
<B>pm</B>을 추가하여 사용하십시오.
예를 들어 <B>14:30</B>과 <B>"2:30 pm"</B>은 모두 오후 2시 30분을 나타냅니다. 이 매개변수에 공백이
들어 있는 경우 큰 따옴표(<B>" "</B>)로 묶으십시오.
</LI><LI>요일과 시간. 공백으로 구분되고 큰 따옴표(<B>" "</B>)로
묶입니다. 이것은 일반적인 재시작을 위한 일반적인 값 유형입니다.
요일의 경우 전체 이름이나 처음 세 문자를 모두 소문자로
시작하십시오(<B>sunday</B> 또는 <B>sun</B>, <B>thursday</B> 또는 <B>thu</B> 등). 시간의 경우 시간만
지정했을 때와 동일한 형식을 사용하십시오.
</LI></UL>
<P>
<P>
<P>원하는 경우 문자열 <B>every</B> 또는
<B>at</B>을 시간 또는 요일 및 시간 정의 앞에 사용하십시오.
이들 단어는 의미를 변경하지는 않으나 <B>bos getrestart</B> 명령의 출력을 보다 이해하기 쉽게 해 줍니다.
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">지정된 시간이 현재 시간에서 한 시간 이내이면 BOS 서버는
적절한 다음 시간(다음 날의 해당 시간이나 다음 주의 해당 요일과 시간)이
될 때까지 재시작을 수행하지 않습니다.
</TD></TR></TABLE>
<P><DT><B>-general
</B><DD>BOS 서버가 자체적으로 재시작되는 일반 재시작 시간을 설정합니다.
<P><DT><B>-newbinary
</B><DD>새 2진 파일을 가진 프로세스에 대한 재시작 시간을 설정합니다.
</DL>
</LI></OL>
<HR><H2><A NAME="HDRWQ173" HREF="auagd002.htm#ToC_199">서버 프로세스 로그 파일 표시</A></H2>
<A NAME="IDX6410"></A>
<A NAME="IDX6411"></A>
<A NAME="IDX6412"></A>
<A NAME="IDX6413"></A>
<A NAME="IDX6414"></A>
<A NAME="IDX6415"></A>
<A NAME="IDX6416"></A>
<A NAME="IDX6417"></A>
<A NAME="IDX6418"></A>
<A NAME="IDX6419"></A>
<A NAME="IDX6420"></A>
<A NAME="IDX6421"></A>
<A NAME="IDX6422"></A>
<A NAME="IDX6423"></A>
<A NAME="IDX6424"></A>
<A NAME="IDX6425"></A>
<A NAME="IDX6426"></A>
<A NAME="IDX6427"></A>
<P>각 파일 서버 시스템의 <B>/usr/afs/logs</B> 디렉토리에는
일부 AFS 서버 프로세스의 정상 작동 중에 발생하는 중요한 이벤트를 상세히
설명하는 로그 파일이 들어 있습니다. 로그 파일의 자체 설명 정보는
프로세스 실패 및 다른 문제점을 평가할 때 매우 도움이 될 수 있습니다.
원격에서 로그 파일을 표시하려면 <B>bos getlog</B> 명령을
실행하십시오.
또한 서버 시스템으로 연결하여 문서 편집기나 다른 파일 표시
프로그램(예: <B>cat</B> 명령)을 사용할 수 있습니다.
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">로그 파일은 주기적으로 데이터베이스 서버 프로세스를 종료했다가
재시작하지 않으면 관리할 수 없을 만큼 커질 수 있습니다(예를 들어
일반 재시작 시간을 사용 불가능하게 한 경우). 이 경우 주기적으로 UNIX
<B>rm</B> 명령을 실행하여 현재 로그 파일을 삭제하는 것이
좋은 방법입니다. 서버 프로세스는 필요할 때 자동으로 새 로그 파일을
작성합니다.
</TD></TR></TABLE>
<A NAME="IDX6428"></A>
<A NAME="IDX6429"></A>
<P><H3><A NAME="Header_200" HREF="auagd002.htm#ToC_200">서버 프로세스 로그 파일을 검토하려면</A></H3>
<OL TYPE=1>
<LI>사용자가 <B>/usr/afs/etc/UserList</B> 파일에 나열되어
있는지 확인하십시오.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI><B>bos getlog</B> 명령을 실행하여 로그 파일을 표시하십시오.
<P>
<PRE>   % <B>bos getlog</B>  &lt;<VAR>machine&nbsp;name</VAR>>  &lt;<VAR>log&nbsp;file&nbsp;to&nbsp;examine</VAR>>
</PRE>
<P>
<P>여기서
<P>
<DL>
<P><DT><B>getl
</B><DD>허용되는 <B>getlog</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>machine name</VAR>
</B><DD>로그 파일을 표시할 서버 시스템을 지정합니다.
<P><DT><B><VAR>log file to examine</VAR>
</B><DD>표시할 로그 파일을 명명합니다. <B>/usr/afs/logs</B>
디렉토리에서 지정된 로그 파일을 표시하려면 다음 파일 이름 중 하나를
제공하십시오.
<UL>
<LI><B>AuthLog</B> 인증 서버 로그 파일에 대해
</LI><LI><B>BackupLog</B> 백업 서버 로그 파일에 대해
</LI><LI><B>BosLog</B> BOS 서버 로그 파일에 대해
</LI><LI><B>FileLog</B> 파일 서버 로그 파일에 대해
</LI><LI><B>SalvageLog</B> 구조 프로그램 로그 파일에 대해
</LI><LI><B>VLLog</B> 볼륨 위치(VL) 서버 로그 파일에 대해
</LI><LI><B>VolserLog</B> 볼륨 서버 로그 파일에 대해
</LI></UL>
<P>
<P>
<P>전체 또는 상대 경로 이름을 제공하여 다른 디렉토리의 파일을 표시할 수
있습니다. 상대 경로 이름은 <B>/usr/afs/logs</B> 디렉토리에
상대적으로 해석됩니다.
</DL>
</LI></OL>
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd008.htm">이전 페이지</A> &#124; <A HREF="auagd010.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B>
<!-- Begin Footer Records  ========================================== -->
<P><HR><B>
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved
</B>
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
