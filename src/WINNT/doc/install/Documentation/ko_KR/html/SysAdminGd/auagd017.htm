<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>관리 안내서</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- c:\IDWBWIN\TEMP\idwt1054\Auagd000.scr converted by idb2h R4.2    -->
<!-- (359) ID Workbench Version (WINNT-WIN95) on 31 Dec 1999 at       -->
<!-- 09:23:05                                                         -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-kr">
<META HTTP-EQUIV="updated" CONTENT="Fri, 31 Dec 1999 09:22:58">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2000 09:22:58">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2001 09:22:58">
</HEAD><BODY>
<!-- (C) IBM Corporation 2000. All Rights Reserved    -->
<BODY bgcolor="ffffff">
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>관리 안내서</H1>
<P>
<A NAME="IDX7583"></A>
<HR><H1><A NAME="HDRWQ449" HREF="auagd002.htm#ToC_535">uss 명령 집합을 사용한 사용자 계정 작성 및 삭제</A></H1>
<P><B>uss</B> 명령 집합을 사용하면 AFS 사용자 계정을 빠르고 쉽게
작성하고 삭제할 수 있습니다. <B>uss add</B> 명령으로 단일 계정을
작성하고 <B>uss delete</B> 명령으로 단일 계정을 삭제하면
<B>uss bulk</B> 명령으로 여러 계정을 작성하고 삭제할 수 있습니다.
<P><B>uss</B> 명령 인터프리터는 여러 계정 구성요소의 구성을 사전에 정의하는
템플릿 파일을 참조하므로 단일 <B>uss add</B>나 <B>uss bulk</B>
명령은 완전한 AFS 사용자 계정을 작성할 수 있습니다. <B>uss delete</B>
명령은 사용자 계정에서 대부분의 구성요소를 삭제하지만 템플릿 파일을 사용하지 않습니다.
<P><B>uss</B> 집합 또한 사용자 사이트에 해당하는 계정 작성과 삭제
작업의 일부를 수행하기 위해 작성하는 쉘 스크립트나 기타 프로그램을 쉽게 통합합니다. 스크립트나
프로그램을 <B>uss</B> 명령이 실행할 때 자동으로 호출하려면 템플릿 파일에서
적합한 명령이나 벌크 입력 파일을 사용하십시오. 이 장의 다양한 절은 여러 가지 가능한
스크립트 사용에 대해 설명합니다.
<P><B>uss</B> 명령을 사용하여 계정을 작성하고 삭제하는 것은 필요한 대부분의
단계를 자동화하고 순서를 올바로 정하므로 권장되는 방법입니다. 이에 대한 대안으로는 다양한
AFS 서버마다 일련의 명령을 실행하는 것으로 좀 더 신중히 관리해야 합니다. 명령은
<A HREF="auagd018.htm#HDRWQ491">사용자 계정 관리</A>를 참조하십시오.
<HR><H2><A NAME="HDRWQ450" HREF="auagd002.htm#ToC_536">명령 요약</A></H2>
<P>이 장에서는 지정된 명령을 사용하여 다음 타스크를 수행하는 방법을 설명합니다.
<BR>
<TABLE WIDTH="100%">
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">단일 사용자 계정 추가
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>uss add</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">단일 사용자 계정 삭제
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>uss delete</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">여러 계정 추가 및 삭제
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>uss bulk</B>
</TD></TR></TABLE>
<HR><H2><A NAME="HDRWQ452" HREF="auagd002.htm#ToC_537">uss 명령 집합 개요</A></H2>
<P><B>uss</B> 집합의 명령을 사용하면 AFS 사용자 계정의 작성과 삭제
작업을 자동화할 수 있습니다.
<UL>
<LI><B>uss add</B> 명령은 계정의 모든 구성요소를 한번에 하나씩
작성합니다. 이는 계정 구성을 정의하는 템플릿 파일을 참조합니다.
</LI><LI><B>uss delete</B> 명령은 계정의 주요 구성요소를 한번에 하나씩
삭제합니다. 이는 템플릿 파일을 사용하지 않으므로 추가 타스크를 수동으로 수행해야
합니다.
</LI><LI><B>uss bulk</B> 명령은 여러 계정을 작성하고 삭제할 수 있습니다. 이는
기타 프로세스 자동화 명령과 함께 여러 계정 작성 및 삭제 명령이 들어 있는 벌크 입력
파일을 참조합니다.
</LI></UL>
<A NAME="IDX7584"></A>
<A NAME="IDX7585"></A>
<P><H3><A NAME="Header_538" HREF="auagd002.htm#ToC_538">AFS 사용자 계정의 구성요소</A></H3>
<P>AFS 사용자 계정에는 여러 구성요소가 있습니다. 필요한 두 구성요소는 보호 데이터베이스와
인증 데이터베이스에 있는 항목이지만 다른 구성요소는 기능과 가용성을 더해줍니다. 다음
정보는 <A HREF="auagd018.htm#HDRWQ491">사용자 계정 관리</A>의 해당 절에도 있지만 편의를 위해 여기서 반복합니다.
<UL>
<LI><I>보호 데이터베이스 항목</I>은 사용자
이름(AFS를 사용하여 인증하는 경우 제공되는 이름)을 정의하고
이를 AFS 사용자 ID(AFS ID)에 맵하며 AFS 서버가 사용자를
내부적으로 참조할 때 사용하는 숫자를 정의합니다. 보호
데이터베이스는 또한 사용자가 속한 그룹을 추적합니다.
자세한 내용은 <A HREF="auagd019.htm#HDRWQ531">보호 데이터베이스 관리</A>를 참조하십시오.
</LI><LI><I>인증 데이터베이스 항목</I>은 사용자의
AFS 암호를 암호 키로 사용하기에 적합한 혼합된 양식으로 기록합니다.
</LI><LI>홈 <I>볼륨</I>은 모든 파일을 파일 서버
기계의 단일 파티션과 함께 사용자 홈 디렉토리에 저장합니다.
볼륨은 그 크기를 제한하는 연관된 <VAR>할당량</VAR>이 있습니다.
볼륨에 대한 완전한 설명은 <A HREF="auagd010.htm#HDRWQ174">볼륨 관리</A>를 참조하십시오.
</LI><LI><I>마운트 포인트</I>는 사용자의 볼륨 내용을
볼 수 있게 만들고 AFS 파일 공간에서 액세스할 수 있게 하며 사용자의
홈 디렉토리로 동작하게 만듭니다. 마운트 포인트에 대한
자세한 내용은 <A HREF="auagd010.htm#HDRWQ183">볼륨 마운트에 대하여</A>를 참조하십시오.
</LI><LI>홈 디렉토리의 <I>액세스 제어 목록(ACL)</I>과
디렉토리의 소유권(<B>ls -ld</B> 명령으로 표시된
대로)에 대한 완전한 액세스 권한은 사용자가 자신의 파일을 관리할
수 있게 합니다. AFS 파일 보호에 대한 자세한 내용은
<A HREF="auagd020.htm#HDRWQ562">액세스 제어 목록 관리</A>를 참조하십시오.
</LI><LI>각 AFS 클라이언트 기계의 <I>로컬 암호
파일 항목</I>(<B>/etc/passwd</B> 파일 또는
이와 동등한 것)을 사용하여 캐쉬 관리 프로그램을 통해
로그인하고 AFS 파일을 액세스할 수 있습니다. 이 장의 후속
절에서는 로컬 암호 파일 항목을 더 자세히 설명합니다.
</LI><LI>기타 선택적 <I>구성 파일</I>을 사용하면
계정을 더 쉽게 사용할 수 있습니다. 이런 파일은 사용자가
더 쉽게 로그인하고 로그아웃하며 전자 메일을 수신하고 인쇄할
수 있도록 도와줍니다.
</LI></UL>
<A NAME="IDX7586"></A>
<A NAME="IDX7587"></A>
<P><H3><A NAME="HDRWQ453" HREF="auagd002.htm#ToC_539">uss 명령의 특권 요구조건</A></H3>
<P><B>uss</B> 명령을 성공적으로 실행하려면 일반적으로 표준 AFS 관리
특권이 전부 필요합니다. 즉, <B>system:administrators</B> 그룹의 멤버쉽,
모든 관련 서버 시스템의 <B>/usr/afs/etc/UserList</B> 파일에 대한 포함
그리고 인증 데이터베이스 항목에서의 <TT>ADMIN</TT> 플래그입니다. 관리 특권에 대한
자세한 내용은 <A HREF="auagd021.htm#HDRWQ581">관리 특권 관리</A>를 참조하십시오.
<A NAME="IDX7588"></A>
<A NAME="IDX7589"></A>
<A NAME="IDX7590"></A>
<A NAME="IDX7591"></A>
<A NAME="IDX7592"></A>
<A NAME="IDX7593"></A>
<A NAME="IDX7594"></A>
<P><H3><A NAME="HDRWQ454" HREF="auagd002.htm#ToC_540">오류 및 인터럽트된 조작 피하기 및 복구</A></H3>
<P>복잡한 모든 조작에는 계적 작성이나 삭제 조작이 완료하기 전에
정지될 수 있는 몇 가지 가능한 이유가 있습니다.
<B>uss</B> 명령을 실행하기 전에 다음 사항을
확인하여 여러 가지 공동 이유를 쉽게 피할 수 있습니다.
<UL>
<LI><A HREF="#HDRWQ453">uss 명령의 특권 요구조건</A>에서 설명한 대로 조작을
끝내는 데 필요한 모든 관리 특권이 있는지 확인합니다.
<B>uss add</B>, <B>uss delete</B>
그리고 <B>uss bulk</B> 명령 사용 방법은 이를
하나의 단계를 포함하고 있습니다.
</LI><LI>템플릿과 벌크 입력 파일의 구문이 올바르고 승인할 수 있는
값을 사용하는지 보기 위해 이를 충분히 읽습니다. 설명은
<A HREF="#HDRWQ463">uss 템플릿 파일 구성</A>과
<A HREF="#HDRWQ489">벌크 입력 파일 구성</A>을 참조하십시오.
</LI><LI>네트워크, 서버 시스템 또는 서버 프로세스가 정지된 것을 알게 되면
<B>uss</B> 명령을 실행하지 마십시오. <B>uss</B> 조작은
AFS의 여러 구성요소에 영향을 주므로 정지가 상태에서 명령이 성공할 가능성은 없습니다.
</LI></UL>
<P>조작을 정지시키는 오류를 피하는 또 다른 방법은 <B>-dryrun</B> 플래그를
실제 명령에서 사용될 기타 인수와 결합하여 <B>uss</B> 명령을 미리보는
것입니다. <B>uss</B> 명령 인터프리터는 실제 명령을 실행하지 않은 상태에서
이 명령으로 수행될 작업의 화면 추적을 생성합니다.
<P><B>-dryrun</B> 플래그를 사용하면 조작을
정지시킬 수 있는 특히 명령행, 템플릿 파일 또는 벌크 입력
파일의 잘못된 구문에 의한 기본 오류를 보여줍니다. 그러나
명령 인터프리터는 실제로 추적중인 작업을 수행하려고 하지
않으므로 가능한 모든 오류를 발견하지는 않습니다. 예를 들어,
명령 인터프리터는 실제로 서버에 접속하지 않으므로 볼륨 서버
정지는 <B>-dryrun</B> 플래그가 포함될 때 볼륨
작성 단계를 정지시키지 않습니다. 이런 정지는 실제 작성 조작을
정지시킵니다.
<A NAME="IDX7595"></A>
<A NAME="IDX7596"></A>
<A NAME="IDX7597"></A>
<P><B>uss</B> 명령 인터프리터는 조작을 정지시킬
만큼 중요하지 않은 오류 조건을 만나면 일반적으로
<TT>uss: Warning:</TT>으로 시작하는 문자열을 생성하고 정지를
피하기 위해 수행하는 작업을 설명합니다. 예를 들어, 사용자의
보호 데이터베이스 항목이 이미 있으면 다음 메시지가 표준 출력
스트림에 나타납니다.
<PRE>   uss: Warning: User '<VAR>user</VAR>' already in the protection database
   The uid for user '<VAR>user</VAR>' is <VAR>AFS UID</VAR>
</PRE>
<P>오류가 더 심각하면 <TT>Warning</TT>라는 단어가 메시지에
나타나지 않고 그 대신 명령 인터프리터가 요청한 작없을 수행하지
못하는 이유를 설명합니다. 이런 오류가 전부
<B>uss</B> 조작을 정지시키는 것은 아니지만
정정 작업이 이루어져야 합니다. 예를 들어, 상위 디렉토리의
ACL에 필요한 권한이 부족하거나 <B>V</B> 명령의
<VAR>mount_point</VAR> 필드에 있는 마운트 포인트 경로 이름이
잘못되었으면 마운트 포인트 작성 작업이 실패합니다. 그러나,
이 오류는 나중에 템플릿 명령이 없는 마운트 포인트 밑에
하위 디렉토리나 파일을 설치하려고할 때까지 작업 조작을
정지시키지는 않습니다.
<P>명령 쉘 프롬프트가 오류 메시지 다음에 바로 리턴하면 오류는
일반적으로 조작을 정지시킬 만큼 심각한 것이었습니다. 오류가
계정 작성이나 삭제 작업을 정지시키면 복구할 수 있는 최상의
방법은 원인을 찾아 고친 후 같은 <B>uss</B>
명령을 다시 실행하는 것입니다.
<A NAME="IDX7598"></A>
<A NAME="IDX7599"></A>
<A NAME="IDX7600"></A>
<A NAME="IDX7601"></A>
<A NAME="IDX7602"></A>
<A NAME="IDX7603"></A>
<P>다음 목록은 계정 작성 명령(벌크 입력 파일에
<B>add</B> 명령이 있는 경우
<B>uss add</B> 명령이나
<B>uss bulk</B> 명령)을 다시 실행할 때
이미 사용자 계정 구성요소가 있으면 어떤 일어 일어나는지 설명합니다.
<UL>
<LI>보호 데이터베이스 항목이 이미 있으면 메시지는 그 존재를
확인하고 연관 AFS UID를 지정합니다.
</LI><LI>인증 데이터베이스 항목이 이미 있으면 메시지는 그 존재를 확인합니다.
</LI><LI>볼륨과 연관 VLDB(Volume Location Database) 항목이
이미 있으면 메시지는 그 존재를 확인합니다. 그러나,
<B>uss</B> 명령 인터프리터는 템플릿
<B>V</B> 명령의 관련 필드 중에서 마지막으로
명령이 실행 된 후 변경된 것이 있으면 볼륨의 할당량, 마운트
포인트 또는 ACL을 변경합니다. <VAR>mount_point</VAR> 필드 값이
변경되면 명령 인터프리터는 새 마운트 포인트를 작성하지만
기존 마운트 포인트를 제거하지 않습니다.
</LI><LI>템플릿 <B>A</B> 명령의 필드 중에서 변경된
것이 있으면 <B>uss</B> 명령 인터프리터는
설명 없이 변경합니다.
</LI><LI>디렉토리, 파일 또는 템플릿 파일 <B>D</B>,
<B>E</B>, <B>F</B>,
<B>L</B> 또는 <B>S</B> 명령에
의해 정의된 연결이 이미 있으면 <B>uss</B> 명령
인터프리터는 기존 요소를 템플릿 정의를 따르는 요소로 바꿉니다.
<B>uss</B> 명령 인터프리터가 주어진 요소를
겹쳐쓰려고 한다는 것을 확인하는 프롬프트 표시 여부를 제어하려면
<B>uss add</B>나 <B>uss bulk</B>
명령에 <B>-overwrite</B> 플래그를 사용하십시오.
<UL>
<LI><B>-overwrite</B> 플래그를 포함하면
명령 인터프리터는 자동으로 확인 없이 모든 요소를 겹쳐씁니다.
</LI><LI>플래그를 생략하면 명령 인터프리터는 각 계정마다 한번씩
연관된 모든 요소를 겹쳐쓸 것인지 묻습니다.
</LI></UL>
</LI><LI>명령 인터프리터는 항상 템플릿 파일에서 <B>X</B> 명령을
재실행합니다. 명령의 결과가 이미 계속되고 있으면 이를 다시 실행하는 것은
<B>uss</B> 명령의 컨텍스트 외부에서 이를 다시 실행하는 것과 같은
효과가 있습니다.
</LI></UL>
<P>다음은 <B>uss delete</B> 명령이 이미 삭제된 계정 구성요소를 참조하는
경우 어떤 일이 일어나는지를 설명합니다.
<UL>
<LI>더 이상 볼륨과 VLDB 항목이 없으면 메시지는 없다는 것을 확인합니다.
</LI><LI>더 이상 인증 데이터베이스 항목이 없으면 메시지는 없다는 것을 확인합니다.
</LI></UL>
<A NAME="IDX7604"></A>
<HR><H2><A NAME="HDRWQ455" HREF="auagd002.htm#ToC_541">uss를 사용한 로컬 암호 파일 항목 작성</A></H2>
<P>셀의 AFS 파일 공간에 대해 인증된 액세스를 확보하려면
사용자는 유효한 AFS 토큰뿐만 아니라 AFS 클라이언트 시스템의
로컬 암호 파일(<B>/etc/passwd</B> 또는
이와 동등한 것)에 있는 항목도 있어야 합니다. 이 절에서는
사용자 AFS UID가 로컬 암호 파일에 표시된 UNIX UID와 일치해야
하는 중요한 이유, 파일의 암호 필드에 들어가는 적합한 값을
설명하고 단일 원본 암호 파일을 작성하는 방법을 간단히 설명합니다.
<P>템플릿 파일의 <B>E</B> 명령을 사용하여 계정
작성의 일부로 로컬 암호 파일 항목을 자동으로 생성하는 방법은
<A HREF="#HDRWQ458">공통 원본 암호 파일 작성</A>을 참조하십시오.
<P>다음 정보는 <A HREF="auagd018.htm#HDRWQ491">사용자 계정 관리</A>의 해당 절에도 있지만
편의를 위해 여기서 반복합니다.
<A NAME="IDX7605"></A>
<A NAME="IDX7606"></A>
<A NAME="IDX7607"></A>
<A NAME="IDX7608"></A>
<A NAME="IDX7609"></A>
<P><H3><A NAME="HDRWQ456" HREF="auagd002.htm#ToC_542">일치하는 AFS와 UNIX UID 지정</A></H3>
<P>사용자 계정은 AFS 사용자 ID 번호(AFS UID)와 UNIX UID가 일치하는
경우 관리하고 사용하기에 가장 쉽습니다. AFS 문서의 모든 명령은
이렇게 일치한다고 간주합니다.
<P>UNIX <B>ls -l</B>과 <B>ls -ld</B>
명령으로 보고된 소유자 이름이 AFS 파일과 디렉토리에 적합하도록
AFS와 UNIX UID를 동일하게 만드는 것이 가장 기본적인 이유입니다.
다음 표준 UNIX 실습에서 파일 서버는 AFS 파일이나 디렉토리의
소유자 필드인 소유자의 AFS UID에 사용자 이름 대신 번호를 기록합니다.
<B>ls -l</B> 명령을 실행하면 이는 AFS 보호
데이터베이스가 아닌 로컬 암호 파일의 맵핑에 따라 UID를 사용자
이름으로 변환합니다. AFS와 UNIX UID가 일치하지 않으면
<B>ls -l</B> 명령은 예상하지 못한(그리고
틀린) 소유자를 보고합니다. 출력은 로컬 암호 파일이 같은 UNIX UID를
다른 이름에 맵하는 경우 다른 클라이언트 시스템에서도
달라질 수 있습니다.
<P>표시된 절에 있는 권장사항에 따라 다양한 사용자 유형에 대해
계정을 작성할 때 AFS와 UNIX UID가 일치하도록 만듭니다.
<UL>
<LI>이미 UNIX UID가 있는 사용자에 대해 AFS 계정을 작성하는
경우 <A HREF="#HDRWQ459">uss를 사용한 기존 UNIX 계정 변환</A>을 참조하십시오.
</LI><LI>셀의 일부 사용자에게 기존 UNIX 계정이 있지만 AFS 계정을
작성중인 사용자에게 없으면 보호 서버에서 AFS UID를 자동으로
할당하도록 하는 것이 최상의 방법입니다. AFS UID와 기존 UNIX
UID가 겹치지 않게 하려면 <A HREF="auagd019.htm#HDRWQ560">AFS UID와 GID 카운터 표시 및 설정</A>의 명령을
사용하여 보호 데이터베이스의 <TT>max user id</TT> 카운터를
제일 큰 UNIX UID보다 높게 설정하십시오.
</LI><LI>기존 UNIX 계정이 있는 사용자가 없으면 보호 서버의 기본값이나
<TT>max user id</TT> 카운터에 설정한 값에서부터 시작하여 AFS
UID를 자동으로 할당하도록 하십시오.
</LI></UL>
<A NAME="IDX7610"></A>
<A NAME="IDX7611"></A>
<P><H3><A NAME="HDRWQ457" HREF="auagd002.htm#ToC_543">로컬 암호 파일에서 암호 지정</A></H3>
<P>AFS를 사용하여 인증하는 것이 사용자를 로컬 파일 시스템에
로그하고 원스텝으로 AFS 토큰을 확보하는 AFS-수정 로그인
유틸리티를 설치하고 구성하는 경우 사용자에게 가장 쉬운
방법입니다. 이런 경우 로컬 암호 파일은 더 이상 대부분의
상황에서 로그인할 수 있는 사용자의 능력을 제어하지 않습니다.
왜냐하면 사용자가 올바른 AFS 암호를 제공하면 AFS-수정 로그인
유틸리티가 로컬 암호 파일을 참조하지 않기 때문입니다. 그럼에도
불구하고 다음과 같은 방법으로 암호 파일 항목의 암호
필드(일반적으로, 두번째 필드)를 사용하여 로그인과 인증을
제어할 수 있습니다.
<UL>
<LI>로컬 로그인과 AFS 인증을 둘다 방지하려면 필드에 별표(*)를 입력하십시오. 이는
주로 특정 사용자가 기계에 로그인하지 못하도록 막는 긴급 상황에 유용하게 사용됩니다.
</LI><LI>사용자가 올바른 AFS 암호를 제공하지 않는 경우 로컬 파일
시스템에 로그인하지 못하도록 막으려면 필드에 표준 13문자
길이 외의 길이의 문자열을 입력하십시오. 이는 로컬 AFS 계정이
있는 사람만 기계에 로그인할 수 있게 할 때 적합합니다. 단일
<B>X</B>나 기타 문자는 이렇게 할 수 있는
가장 쉬운 방법입니다.
</LI><LI>사용자가 틀린 AFS 암호를 제공한 후에도 로컬 파일 시스템에
로그인할 수 있게 하려면 표준 UNIX 암호-설정
명령(<B>passwd</B> 또는 이와 동등한 것)을 실행하여
표준 UNIX 암호화 암호를 기록하십시오.
</LI></UL>
<P>AFS-수정 로그인 유틸리티를 사용하지 않으면 표준 UNIX 암호를
사용자가 사용하는 모든 클라이언트 기계의 로컬 암호 파일에
입력해야 합니다. 사용자는 로컬 파일 시스템에만 로그인한 후
<B>klog</B> 명령을 실행하여 AFS를 통해 인증해야
합니다. 로컬 암호 파일에 있는 암호와 인증 데이터베이스가
같으면 가장 간단하지만 이를 권하지는 않습니다.
<A NAME="IDX7612"></A>
<A NAME="IDX7613"></A>
<A NAME="IDX7614"></A>
<A NAME="IDX7615"></A>
<A NAME="IDX7616"></A>
<P><H3><A NAME="HDRWQ458" HREF="auagd002.htm#ToC_544">공통 원본 암호 파일 작성</A></H3>
<P>이 절에서는 <B>uss</B> 명령을 사용하여 사용자 계정을 작성할 때
로컬 암호 파일의 공통 원본 버전을 작성하는 방법을 설명합니다. 단계 순서는 다음과
같습니다.
<OL TYPE=1>
<LI>템플릿 파일에 <B>E</B> 명령을 포함하여 로컬 암호 파일 항목의 형식을
사용하는 1-행 파일을 작성합니다.
</LI><LI>1-행 파일을 로컬 암호 파일의 공통 원본 버전에 통합합니다. 이 파일을
AFS에 저장하는 것이 좋습니다. 다음 두 스크립트 예를 참조하여 이 단계를 자동하는
방법을 알아보십시오.
</LI><LI><A HREF="auagd016.htm#HDRWQ419">package 프로그램을 사용한 클라이언트 시스템 구성</A>의 설명대로 AFS <B>package</B> 유틸리티를
사용하여 각 클라이언트 시스템에 공동 암호 파일을 분배합니다.
</LI></OL>
<P>예로서, ABC사에서 사용하는 템플릿 파일에는 <B>/afs/.example.com/common/etc/newaccts</B>
디렉토리에 <B>passwd_</B><VAR>username</VAR>라고 하는 파일을 작성하기
위한 다음 <B>E</B> 명령이 들어 있습니다(템플릿 파일의 전체 내용은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>에 있고 <B>E</B> 명령의 전체 설명은
<A HREF="#HDRWQ476">E 명령어를 사용하여 한 행 파일 작성</A>에 있음).
<PRE>   E /afs/.example.com/common/etc/newaccts/passwd_$USER 0644 root \
        "$USER:X:$UID:11:$NAME:$MTPT:/bin/csh"
</PRE>
<P>사용자 이름 <B>smith</B>를 사용하는 사용자 Joe L. Smith에게 이 명령은
다음과 같은 행이 들어 있는 <B>passwd_smith</B>라는 파일을 작성합니다.
<PRE>   smith:X:1205:11:Joe L. Smith:/afs/example.com/usr/usr1/smith:/bin/csh
</PRE>
<P>쉘 스크립트는 아마도 이 방법으로 작성된 파일 집합을 공통 원본 암호 파일에 통합하는
가장 쉬운 방법일 것입니다. 다음과 같이 두 예제 쉘 스크립트가 있습니다. 프로세스를 더욱
자동화하려면 파일 서버 시스템의 <B>/usr/afs/local/BosConfig</B>
디렉토리에 <B>cron</B> 프로세스를 작성하여 매일 지정된 시간에 쉘
스크립트를 실행할 수 있습니다. 자세한 내용은 <A HREF="auagd009.htm#HDRWQ162">새 프로세스를 작성 및 시작하려면</A>을
참조하십시오.
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">다음 예제 스크립트는 제안일뿐입니다. 이를 사용하거나 이와 비슷한 스크립트를
만들려면 스크립트를 검사하여 원하는 결과가 나오는지 알아봐야 합니다. 가능하면 검사
환경에서 하는 것이 좋습니다.
</TD></TR></TABLE>
<P><B>예제 C 쉘 스크립트</B>
<P>첫 예제는 ABC사 셀에 적합한 간단한 C 쉘 스크립트입니다. 이는
<B>/afs/.example.com/common/uss/newaccts</B> 디렉토리에 있는 각각의
파일을 <B>/afs/.example.com/common/etc</B> 디렉토리에 있는 전역 암호
파일의 새 버전에 통합하며 파일을 알파벳순으로 정렬합니다. 현재 버전을
<B>.old</B> 확장자로 저정한 후 개별적인 파일을 제거하는 작업은
신중히 이루어져야 합니다.
<PRE>   set  dir = /afs/.example.com/common
   cat  $dir/uss/newaccts/passwd_* $dir/etc/passwd  >!  $dir/etc/passwd.new
   mv  $dir/etc/passwd  $dir/etc/passwd.old
   sort  $dir/etc/passwd.new  >  $dir/etc/passwd
   rm  $dir/etc/passwd.new  $dir/uss/newaccts/passwd_*
</PRE>
<P><B>예제 Bourne 쉘 스크립트</B>
<P>두번째의 좀 더 세련된 예제는 Bourne 쉘 스크립트로서 전역 암호 파일에 통합될
새 <B>passwd_</B><VAR>username</VAR> 파일이 있다는 것을 먼저
확인합니다. 실행하는 중에 각 새 항목이 아직 없는지 점검합니다. 짧은 C 쉘 예제처럼
이는 <B>/afs/.example.com/common/uss/newaccts</B> 디렉토리에 있는 개별적인
파일을 <B>/afs/.example.com/common/etc</B> 디렉토리의 전역
<B>passwd</B> 파일의 새 버전에 통합합니다.
<PRE>   #!/bin/sh
   DESTDIR=/afs/.example.com/common/uss/newaccts
   cd  $DESTDIR
   DEST=/afs/.example.com/common/etc
   cp /afs/.example.com/common/etc/passwd   /afs/.example.com/common/uss/newaccts/passwd
   echo "copied in passwd file."
   PASSWD=/afs/.example.com/common/uss/newaccts/passwd
   ENTRIES=`ls passwd_*`
   case $ENTRIES in
   "")
        echo No new entry found to be added to passwd file
        ;;
   *)
        echo  "Adding new users to passwd file."
        for  i  in  $ENTRIES
        do
           cat  $i  |  awk  -F:  '{print $1  >  "foo"}'
           USER=`cat foo`
           case  `egrep  -e  \^$USER\: $PASSWD` in
           "")
                   echo  adding  $USER
                   cat  $i  >>  $PASSWD
                   ;;
           *)
                   echo  $USER already in passwd file
                   ;;
   esac
           mv  $i  ../old.passdir/done_${i}
        done
        cd  /afs/.example.com/common/uss/newaccts
        echo  "sorting password file"
        sort  ${PASSWD}  >  ${PASSWD}.sorted
        echo  "installing files"
        install  ${PASSWD}.sorted ${DEST}/passwd
        echo  "Password file is built, sorted and installed."
        ;;
   esac
</PRE>
<A NAME="IDX7617"></A>
<A NAME="IDX7618"></A>
<A NAME="IDX7619"></A>
<HR><H2><A NAME="HDRWQ459" HREF="auagd002.htm#ToC_545">uss를 사용한 기존 UNIX 계정 변환</A></H2>
<P>이 절에서는 AFS 계정으로 변환되어야 하는 기존 UNIX 계정이 있는 경우 고려해야 하는 3가지
주요 문제를 설명합니다.
<P><H3><A NAME="HDRWQ460" HREF="auagd002.htm#ToC_546">UNIX와 AFS UID 일치시키기</A></H3>
<P>앞에서 설명했듯이 AFS 사용자는 인증된 사용자로 모든 클라이언트 시스템에서
AFS 파일 공간을 액세스할 수 있도록 로컬 암호 파일에 항목이 있어야 합니다. 관리와
사용 모두 UNIX UID와 AFS UID가 일치할 때 훨씬 쉬워집니다. 기존 UNIX 계정을 변환할
때 다음과 같이 두 가지 대안이 있습니다.
<UL>
<LI>AFS UID를 기존 UNIX UID와 일치시킵니다. 이 경우, AFS 계정을 작성하면서 AFS UID를
스스로 지정해야 합니다.
<UL>
<LI><B>uss add</B> 명령을 사용하는 경우
<B>-uid</B> 인수를 포함하십시오.
</LI><LI><B>uss bulk</B> 명령을 사용하는 경우
원하는 UID를 벌크 입력 파일에 있는 <B>add</B>
명령의 <VAR>uid</VAR> 필드에 지정하십시오.
</LI></UL>
<P>
<P>사용자 UNIX UID를 유지하고 있으므로 로컬 암호 파일 항목에서
UID를 변경하지 않아도 됩니다. 그러나, AFS-수정 로그인
유틸리티를 사용하는 경우 아마도 항목에서 암호 필드를 변경해야
합니다. 암호 필드에 있는 값이 AFS-수정 로그인 유틸리티를 사용한
로그인에 어떻게 영향을 주는지에 대해서는
<A HREF="#HDRWQ455">uss를 사용한 로컬 암호 파일 항목 작성</A>을 참조하십시오.
<P>
<P>현재 또는 앞으로 기존 UNIX UID가 없는 사용자를 위해 AFS 계정을
작성해야 하는 경우 새 AFS UID가 기존 UNIX UID와 충돌하지 않아야
합니다. 보호 데이터베이스에서 <TT>max user id</TT> 카운터를
가장 큰 기존 UNIX UID보다 큰 값으로 설정하는 것이 가장
쉬운 방법입니다. <A HREF="auagd019.htm#HDRWQ560">AFS UID와 GID 카운터 표시 및 설정</A>을 참조하십시오.
</LI><LI>기존 UNIX UID가 보호 서버에서 자동으로 지정하는
새 AFS UID와 일치하도록 변경합니다.
<P>
<P>보호 서버가 AFS 계정을 작성할 때 AFS UID를 자동으로 할당하도록
합니다. 게정 작성중에 로컬 암호 파일에 대해 새 항목을 작성하는
방법은 <A HREF="#HDRWQ455">uss를 사용한 로컬 암호 파일 항목 작성</A>을 참조하십시오.
<P>
<P>UNIX UID 변경에는 한 가지 장애가 있습니다. 사용자가 AFS 사용자가
되기 전에 로컬 파일 시스템에서 소유한 모든 파일과 디렉토리는
계속 소유자 필드에 이전 UID를 가지고 있습니다.
<B>ls -l</B>과 <B>ls -ld</B> 명령으로
올바른 소유자를 표시하려면 파일을 로컬 파일 시스템에 남겨 놓거나
AFS로 옮기던지 간에 <B>chown</B> 명령을 사용하여
값을 사용자의 새 UID로 변경해야 합니다. <A HREF="#HDRWQ462">AFS로 로컬 파일 이동</A>을
참조하십시오.
</LI></UL>
<P><H3><A NAME="HDRWQ461" HREF="auagd002.htm#ToC_547">제대로 암호 필드 설정하기</A></H3>
<P>기존 UNIX 계정에는 이미 암호 필드에 (섞인) 암호가 있는 로컬 암호 파일의 항목이
있습니다. 아마도 사용하는 로그인 유틸리티의 유형에 따라 필드의 값을 변경해야 합니다.
<UL>
<LI>AFS와 같이 사용하도록 로그인 유틸리티가 수정되지 않으면 실제 암호는 로컬 암호
필드 항목의 암호 필드에 나타나야 합니다(섞인 형태로).
</LI><LI>AFS와 같이 사용하도록 로그인 유틸리티가 수정되면 로그인 유틸리티의 동작에
서로 다른 영향을 주는 값 중 하나를 선택합니다. <A HREF="#HDRWQ455">uss를 사용한 로컬 암호 파일 항목 작성</A>을 참조하십시오.
</LI></UL>
<P>로컬 암호 파일 항목에 실제 암호를 배치하도록 선택하면 <A HREF="#HDRWQ476">E 명령어를 사용하여 한 행 파일 작성</A>에서
설명하는 것처럼 템플릿 파일 <B>E</B> 명령어(instruction)를
사용할 때 더미 암호를 정의할 수 있습니다.
사용자가 UNIX 암호 설정 명령(<B>passwd</B> 또는 동급)을 실행하여 이 더미 암호를 실제의 비밀 암호로 바꾸게 하십시오.
<P><H3><A NAME="HDRWQ462" HREF="auagd002.htm#ToC_548">AFS로 로컬 파일 이동</A></H3>
<P>기존 UNIX 계정이 있는 새 AFS 사용자는 기계의 로컬 파일 시스템에 이미 저장된
파일과 디렉토리가 있을 것으므로 이를 새 홈 볼륨으로 전송하는 것이 좋습니다. 가장 쉬운
방법은 이를 AFS 클라이언트 기계의 로컬 디스크로 이동한 다음 UNIX <B>mv</B>
명령을 사용하여 이를 사용자의 새 AFS 홈 디렉토리로 전송하는 것입니다.
<P>파일과 디렉토리를 AFS로 옮기면서 그 모드 비트 변경의 의미를 염두에 두십시오. AFS는
모드 비트의 두번째와 세번째 세트(그룹 및 기타)를 무시하고 첫번째 세트(소유자 비트)를
직접 사용하지 않지만 ACL의 항목과 함께만 사용합니다(자세한 내용은 <A HREF="auagd020.htm#HDRWQ580">AFS가 UNIX 모드 비트를 해석하는 방법</A>
참조). ACL이 최소한 모드 비트만큼만 파일이나 디렉토리를 보호하도록 하십시오.
<P>사용자의 UNIX UID가 새 AFS UID와 일치하도록 변경하기로 한 경우 UNIX 파일과 디렉토리의
소유권도 변경해야 합니다. <B>system:administrators</B> 그룹의 구성원이
일단 AFS에 상주하면 파일과 디렉토리에서 <B>chown</B> 명령을 실행할 수
있습니다.
<A NAME="IDX7620"></A>
<A NAME="IDX7621"></A>
<A NAME="IDX7622"></A>
<HR><H2><A NAME="HDRWQ463" HREF="auagd002.htm#ToC_549">uss 템플릿 파일 구성</A></H2>
<P><B>uss</B> 명령을 사용하여 사용자 계정을
작성하는 것은 보통 개별 명령을 사용하는 것보다 더 편리합니다.
사용자가 면밀하게 계정 작성 프로세스를 제어하게 되지만
<B>uss</B> 템플릿 파일을 사용하면 계정 구성의
다양한 측면을 미리 정의할 수 있습니다. <B>uss</B>
명령을 실행하기 전에 템플릿을 구성하게 되므로 구성 세부사항을
주의해서 고려해 보고 구문 오류를 수정할 시간을 갖게 됩니다.
다음 목록은 템플릿 사용의 추가적인 이점을 요약해서 설명합니다.
<UL>
<LI>계정 구성요소를 작성 또는 삭제할 올바른 순서 또는 각 명령 인수의
순서를 기억할 필요가 없으므로 오류 발생 소지가 줄어 듭니다.
</LI><LI>동일한 정보를 여러 번 입력할 필요가 없습니다. 대신 명령행에서
가능한 한 적게 입력할 수 있게 해 주는 템플릿 파일에 상수 및 변수를
입력할 수 있습니다. <A HREF="#HDRWQ465">템플릿 파일에서 상수 및 변수 사용</A>을 참조하십시오.
</LI><LI>다른 유형의 사용자에 대해 다른 템플릿을 작성할 수 있습니다.
주어진 사용자에 대해 어떤 구성요소가 다른지 기억하지 말고 대신
<B>uss add</B> 또는 <B>uss bulk</B>
명령을 실행할 때 적절한 템플릿을 지정하십시오.
</LI><LI><A HREF="#HDRWQ464">세 가지 유형의 사용자 계정 작성</A>에서 설명하는 것처럼 템플릿에
특정 정보를 포함시키거나 생략함으로써 세 가지 AFS 계정 중
하나(인증 전용, 기본 또는 전체)를 작성할 수 있습니다.
</LI></UL>
<P>다음 목록은 템플릿 파일에 나타날 수 있는 지침을 설명하고
좀더 자세한 정보를 제공하는 후속 절을 알려 줍니다. 이 목록은
다른 유형의 명령어간의 종속성을 제대로 처리하는 데 있어서
최적이 될 수 있는 순서로 후속 절을 나열하고 있습니다.
<DL>
<P><DT><B><B>G</B>
</B><DD><B>uss</B> 명령 인터프리터가 새로 작성한
홈 디렉토리를 공평하게 분배하는 상위 디렉토리의 집합 중 하나에
해당하는 디렉토리를 정의합니다. <B>V</B>
명령어(instruction)의 <VAR>mount_point</VAR> 필드에 해당 템플릿
파일 변수 $AUTO를 입력하십시오. <A HREF="#HDRWQ472">G 명령어를 사용하여 사용자 홈 디렉토리의 공평한 분배</A> 및
<A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>을 참조하십시오.
<P><DT><B><B>V</B>
</B><DD>볼륨을 작성하고, 이를 사용자 홈 디렉토리로서 AFS 파일
공간의 지정된 위치에 마운트하고, 볼륨의 할당량을 설정하고,
디렉토리에 대한 소유자와 ACL을 정의합니다. 이 명령어는 비어
있지 않은 (0길이가 아닌) 템플릿에 나타나야 합니다.
<A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>을 참조하십시오.
<P><DT><B><B>D</B>
</B><DD>보통 새로운 홈 디렉토리의 하위 디렉토리에 해당하는 디렉토리를
작성하고 그 모드 비트, 소유자 및 ACL을 설정합니다.
<A HREF="#HDRWQ474">D 명령어를 사용하여 디렉토리 작성</A>을 참조하십시오.
<P><DT><B><B>F</B>
</B><DD>프로토타입을 복사하여 파일을 작성하고 그 모드 비트와 소유자를 설정합니다.
<A HREF="#HDRWQ475">F 명령어를 사용하여 프로토타입에서 파일 작성</A>을 참조하십시오.
<P><DT><B><B>E</B>
</B><DD>명령어 자체의 내용에 복사하여 단일 행 파일을 작성하고 이 파일의
모드 비트와 소유자를 설정합니다. <A HREF="#HDRWQ476">E 명령어를 사용하여 한 행 파일 작성</A>을 참조하십시오.
<P><DT><B><B>L</B>
</B><DD>하드 연결을 작성합니다. <A HREF="#HDRWQ477">L 및 S 명령어를 사용한 연결 작성</A>을 참조하십시오.
<P><DT><B><B>S</B>
</B><DD>기호 연결을 작성합니다. <A HREF="#HDRWQ477">L 및 S 명령어를 사용한 연결 작성</A>을 참조하십시오.
<P><DT><B><B>A</B>
</B><DD>암호 및 인증 시도에 대한 제한을 부여하여 계정 보안을 향상시킵니다.
<A HREF="#HDRWQ478">A 명령어로 계정 보안 높이기</A>를 참조하십시오.
<P><DT><B><B>X</B>
</B><DD>명령을 실행합니다. <A HREF="#HDRWQ479">X 명령어를 사용하여 명령 실행</A>을 참조하십시오.
</DL>
<A NAME="IDX7623"></A>
<A NAME="IDX7624"></A>
<A NAME="IDX7625"></A>
<P><H3><A NAME="HDRWQ464" HREF="auagd002.htm#ToC_550">세 가지 유형의 사용자 계정 작성</A></H3>
<P><B>uss add</B> 및 <B>uss bulk</B> 명령을
사용하면 기능 레벨에서 다른 위치를 차지하는 세 가지 유형의 계정을 작성할
수 있습니다. 유형에
대한 설명은 <A HREF="auagd007.htm#HDRWQ57">AFS 사용자 계정 구성</A>을 참조하십시오.
다음 목록은 각 유형에 대한 템플릿을 구성하는 방법을 설명합니다.
<UL>
<LI>인증 전용 계정을 작성하려면 비어 있는 (0길이) 템플릿 파일을 작성하십시오.
이러한 계정은 인증 데이터베이스 및 보호 데이터베이스의 항목인 두 가지
구성요소만 가집니다.
</LI><LI>기본 계정을 작성하려면 <A HREF="#HDRWQ472">G 명령어를 사용하여 사용자 홈 디렉토리의 공평한 분배</A>에서 설명하는 것처럼
홈 디렉토리를 공평하게 분배하려는 경우 <B>V</B> 명령어와
<B>G</B> 명령어를 포함시키십시오. 인증
데이터베이스와 보호 데이터베이스 항목 외에 이 계정 유형에는 소유자와 ACL이 적절히 설정된
홈 디렉토리에 마운트된 볼륨이 포함됩니다.
</LI><LI>전체 계정을 작성하려면 적절하게 <B>D</B>, <B>E</B>, <B>F</B>, <B>L</B> 및 <B>S</B> 명령어를 포함시키고 <B>V</B> 및 <B>G</B> 명령어도 포함시키십시오. 이 유형의
계정에는 로그인, 인쇄 및 메일 전달과 같은 기본 기능에 대한 구성 파일이
들어 있습니다. 일부 유용한 구성 파일 유형에
대한 내용은 <A HREF="auagd007.htm#HDRWQ60">새 AFS 계정에 표준 파일 작성</A>을 참조하십시오.
</LI></UL>
<A NAME="IDX7626"></A>
<A NAME="IDX7627"></A>
<A NAME="IDX7628"></A>
<A NAME="IDX7629"></A>
<P><H3><A NAME="HDRWQ465" HREF="auagd002.htm#ToC_551">템플릿 파일에서 상수 및 변수 사용</A></H3>
<P><B>uss</B> 템플릿 파일의 각 명령어는 작성하는 요소의 특성을
정의하는 몇몇 필드를 가집니다. 예를 들어 <B>D</B> 명령어의
필드는 디렉토리의 경로명, 소유자, 모드 비트 및 ACL을 정의합니다.
<P>변수, 상수 또는 두 가지의 조합에 해당하는 세 가지 유형의
값을 필드에 삽입할 수 있습니다. 해당 값은 원하는 구성에
따라 달라지며 사용자가 <B>uss add</B> 명령에
제공하는 인수 또는 사용자가 벌크 입력 파일
<B>add</B> 명령어에 포함시키는 필드를 결정합니다.
<P>계정 구성의 한 측면이 모든 사용자에게 동일하면 문자 스트링을
삽입하여 해당 필드에 상수 값을 정의하십시오. 예를 들어, 모든
사용자 볼륨에 10,000 KB의 공간 할당량을 지정하려면
<B>V</B> 명령어의 <VAR>quota</VAR> 필드에
문자열 <B>10000</B>을 추가하십시오.
<P>한편 계정 구성의 한 측면이 사용자마다 다른 경우 해당 필드에
변수를 추가하십시오. 각 계정을 작성할 때
<B>uss add</B> 명령에 해당 인수를 제공하거나
벌크 입력 파일의 <B>add</B> 명령어의 해당
필드에 값을 제공하여 변수에 값을 제공하십시오.
<P><B>uss</B> 명령 집합은 각각이
<A HREF="#TBLWQ466">표 3</A>에서 요약된 것처럼 그 값의
해당 원본을 가지고 있는 템플릿 변수의 집합을 정의합니다.
어떤 목적을 가지고 있는지에 대한 설명을 보려면 각
템플릿(<A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>에서 <A HREF="#HDRWQ479">X 명령어를 사용하여 명령 실행</A>)에
대해 다음 절을 참조하십시오.
<BR>
<P><B><A NAME="TBLWQ466" HREF="auagd004.htm#FT_TBLWQ466">표 3. uss 템플릿 변수 값의 원본</A></B><BR>
<TABLE WIDTH="100%" BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>변수</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>값 원본</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$AUTO
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">템플릿에서 이전 <B>G</B> 명령어
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$MTPT
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-mount</B> 인수
또는 벌크 입력 파일 <B>add</B> 명령어의 <VAR>mount_point</VAR>
필드, <B>V</B> 명령어에서, 후속 명령어에서
<VAR>mount_point</VAR> 필드의 <B>V</B> 명령어
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$NAME
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">제공되는 경우 <B>uss add</B> 명령에 대한 <B>-realname</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>mount_point</VAR> 필드, 그렇지 않은 경우 <B>uss add</B>
명령에 대한 <B>-user</B> 인수 또는 벌크 입력 파일
<B>add</B> 명령어의 <VAR>username</VAR> 필드
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$PART
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-partition</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>partition</VAR> 필드
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$PWEXPIRES
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-pwexpires</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>password_expires</VAR> 필드
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$SERVER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-server</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>file_server</VAR> 필드
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$UID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">제공되는 경우 <B>uss add</B> 명령에 대한 <B>-uid</B>
인수 또는 벌크 입력 <B>add</B> 명령어의
<VAR>uid</VAR> 필드, 그렇지 않은 경우 보호 서버에 의해 자동으로 할당됨
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$USER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-user</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>username</VAR> 필드
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$1에서 $9
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>uss add</B> 명령에 대한 <B>-var</B>
인수 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>var1</VAR>에서 <VAR>var9</VAR> 필드
</TD></TR></TABLE>
<P>변수의 일반적인 사용 방식은 사용자마다 다를 수 있는 사용자 볼륨을 포함하는
파일 서버 시스템 및 파티션을 정의하는 것입니다. <B>V</B>
명령어의 <VAR>server</VAR> 필드에 $SERVER 변수를 입력하고 그
<VAR>partition</VAR> 필드에 $PART 변수를 입력하십시오. <B>uss add</B>
명령을 사용하는 경우 <B>-server</B> 및 <B>-partition</B>
인수를 사용하여 원하는 값을 제공하십시오.
<B>uss bulk</B> 명령을 사용하는 경우 벌크 입력 파일에 있는
각 사용자의 <B>add</B> 명령어의 <VAR>file_server</VAR> 및
<VAR>partition</VAR> 필드에 원하는 값을 제공하십시오.
<A NAME="IDX7630"></A>
<A NAME="IDX7631"></A>
<P>변수 $1 - $9은 계정의 다른 측면을 사용자 정의하는 데 사용할 수
있습니다. <B>uss add</B> 명령에 대한 <B>-var</B> 인수를 사용하거나 벌크 입력 파일 <B>add</B>
명령어의 해당 필드에 이들 변수에 대한 값을 제공하십시오.
<B>-var</B> 인수는 각 인스턴스가 공백으로 구분된 두 부분인
숫자 색인과 값을 가진다는 면에서 특이합니다. 숫자 변수의 사용 예를 보려면
<A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>에서 <VAR>mount_point</VAR> 및 <VAR>quota</VAR> 필드에
대한 설명을 참조하십시오.
<P>계정 구성의 일부 측면이 부분적으로 상수이고 부분적으로 변수인 경우 명령어
필드에서 변수와 상수를 조합할 수 있습니다. 예를 들어 Example Corporation에서
<B>/afs/example.com/usr</B> 디렉토리에 사용자 볼륨을 마운트한다고
가정해 봅시다. 이 경로 이름 부분은 상수이지만 마운트 포인트와 홈 디렉토리의
이름은 $USER 변수에 해당하는 사용자의 사용자 이름입니다. 이러한 방식으로
계정을 구성하려면 다음과 같이 <B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에서 상수 문자열과 변수를 조합해서 사용하십시오.
<PRE>   /afs/example.com/usr/$USER
</PRE>
<P>그런 다음 <B>uss add</B> 명령에 대한 <B>-user</B> 인수를 사용하거나 벌크 입력 파일에 있는 각 사용자의
<B>add</B> 명령어의 <VAR>username</VAR> 필드에 $USER 변수에
대한 값을 제공하십시오.
<A NAME="IDX7632"></A>
<A NAME="IDX7633"></A>
<P><H3><A NAME="HDRWQ468" HREF="auagd002.htm#ToC_552">템플릿 파일을 저장할 위치</A></H3>
<P>템플릿은 이 템플릿이 인증 전용 계정을 작성하기에 적절한 0길이 파일인
경우에도 <B>uss</B> 명령 인터프리터가 <B>uss add</B>
또는 <B>uss bulk</B> 명령을 실행할 때 사용할 수 있어야
합니다.
<P><B>uss add</B> 또는 <B>uss bulk</B> 명령에
대해 <B>-template</B> 인수를 제공하지 않으면
명령 인터프리터는 다음의 각 디렉토리에서 <B>uss.template</B>이라는
템플릿 파일을 검색합니다.
<OL TYPE=1>
<LI>현재 작업 디렉토리
</LI><LI><B>/afs/<VAR>cellname</VAR>/common/uss</B>, 여기서
<VAR>cellname</VAR>은 로컬 셀입니다.
</LI><LI><B>/etc</B>
</LI></OL>
<P>다른 이름을 가지거나 다른 디렉토리에 저장되어 있는 템플릿 파일을 사용하려면
<B>uss add</B> 또는 <B>uss bulk</B> 명령에
<B>-template</B> 인수를 포함시키십시오. 파일 이름만 제공하는
경우 명령 인터프리터는 바로 전에 나열된 디렉토리에서 해당 파일을 찾습니다.
경로 이름과 파일 이름을 제공하면 지정된 디렉토리만 검색하며 현재 작업 디렉토리에
상대적으로 부분 경로 이름을 해석합니다.
<A NAME="IDX7634"></A>
<A NAME="IDX7635"></A>
<P><H3><A NAME="HDRWQ469" HREF="auagd002.htm#ToC_553">템플릿 구성을 위한 몇몇 일반 규칙</A></H3>
<P>이 절에서는 템플릿 파일을 구성할 때 따라야 할 몇몇 일반 규칙을 요약해서
설명합니다. 각 명령어 구문 정의를 보려면 다음 절(<A HREF="#HDRWQ472">G 명령어를 사용하여 사용자 홈 디렉토리의 공평한 분배</A>에서
<A HREF="#HDRWQ479">X 명령어를 사용하여 명령 실행</A>)을 참조하십시오.
<UL>
<LI>변수가 템플릿 내의 아무 위치에 있는 요소에서 그 값을 취하면 정의는
이 참조보다 앞에 나와야 합니다. 다음 순서로 명령어 행을 추가하면 대개
올바른 변수 해석이 수행됩니다.
<P>
<P><B>G  V  D  F  E  L  S  A X</B>
</LI><LI>각 명령어의 필드는 각 명령에 대한 다음 절에 나오는 것처럼 명령어 구문
정의에 의해 지정되는 순서로 나타나야 합니다. 필드를 생략할 수는 없습니다.
각 필드를 하나 이상의 공백을 사용하여 이웃 필드로 분리하십시오.
</LI><LI>경로 이름을 지정할 때는 전체 이름을 제공하십시오. 부분 경로 이름은
현재 작업 디렉토리(<B>uss</B> 명령이 실행된 디렉토리)에
상대적으로 해석되어 의도하지 않은 결과를 발생하기도 합니다.
</LI><LI>각 명령어는 템플릿 파일의 단일 행에 나타나야 하며 개행
문자(<B>&lt;Return></B>)는 명령어 맨 뒤에만 나타나야 합니다.
이 문서에서는 일부 예제 명령어가 둘 이상의 행에 나타나지만 이것은 이해하기
편리하게 하기 위한 것에 불과합니다.
</LI><LI><B>uss add</B> 명령에 해당 인수를 포함시키거나
벌크 입력 파일 <B>add</B> 명령어의 해당 필드에 값을 삽입하여
템플릿에 나타나는 모든 변수에 대한 값을 제공하십시오. 누락된 값이 있으면
전체 작성 조작이 중단됩니다.
변수가 템플릿 파일에 나타나지 않으면 명령 인터프리터는 사용자가 입력하는
경우에도 해당 명령행 인수나 벌크 입력 파일의 필드를 무시합니다.
</LI><LI>템플릿 파일에 공백 행을 사용하여 판독성을 높일 수 있습니다.
파일에 주석을 입력하는 경우 각 주석 행은 숫자 기호(<B>#</B>)로
시작해야 합니다.
</LI></UL>
<P><H3><A NAME="HDRWQ470" HREF="auagd002.htm#ToC_554">로컬 디스크 디렉토리 및 파일 작성에 대하여</A></H3>
<P><B>D</B>, <B>E</B> 및 <B>F</B>
명령어를 사용하여 <B>uss</B> 명령을 실행하고 있는 시스템의
로컬 파일 시스템에서 디렉토리나 파일을 작성할 수 있으나 이런 디렉토리나
파일을 사용하는 것은 권장되지 않습니다. 이렇게 하면 다음과 같은 두 가지
잠재적인 문제가 발생할 수 있습니다.
<UL>
<LI>로컬 파일 시스템은 새 로컬 디스크 디렉토리나 파일의
소유권을 작성자에게 자동으로 할당합니다. 사용자가 오브젝트를
작성하고 있는 <B>uss</B> 명령의 실행자인 경우
이 시스템은 사용자의 현재 UNIX UID를 기록합니다. 이 UID가
정확하지 않고 오브젝트가 작성될 때 다른 사용자를 지정하려면
로컬 수퍼유저 <B>루트</B>로서 로그인해야
합니다(로컬 파일 시스템은 <B>루트</B> 사용자만
UNIX <B>chown</B> 명령을 실행할 수 있게 허용하며
이 명령은 <B>uss</B> 명령 인터프리터가
기본값으로부터 소유자를 변경하기 위해 호출하는 명령입니다).
또한 <B>uss add</B> 또는
<B>uss bulk</B> 명령에 대해
<B>-admin</B> 인수를 사용해서 권한
있는 AFS 관리자로서 인증을 받아야 합니다.
<B>uss</B> 명령 인터프리터가 새 계정의 일부로
항상 작성하는 인증 데이터베이스 및 보호 데이터베이스 항목은
관리자만 작성할 수 있습니다.
<P>
<P>대안은 <B>uss</B> 조작이 완료된 후에 로컬
수퍼유저 <B>루트</B>가 된 다음 필요한
<B>chown</B> 명령을 실행하는 것입니다.
그러나 이런 방법은 자동으로 수행할 수 있는 계정 작성
프로세스가 상당히 복잡해지는 결과를 낳습니다.
</LI><LI>로컬 디스크 디렉토리를 작성하면 <B>uss</B>
명령 인터프리터가 로컬 디렉토리의 ACL을 성공적으로 설정할
수 없으므로 항상 오류 메시지가 생성됩니다. 그러나 이
디렉토리는 작성되고 값은 여전히 <B>D</B>
명령어의 <VAR>ACL</VAR> 필드에 나타납니다.
</LI></UL>
<P>시스템의 로컬 디스크 구성에 대해 권장되는 방법은 그 대신 AFS
<B>package</B> 유틸리티를 사용하는 것입니다.
<A HREF="auagd016.htm#HDRWQ419">package 프로그램을 사용한 클라이언트 시스템 구성</A>을 참조하십시오.
<A NAME="IDX7636"></A>
<A NAME="IDX7637"></A>
<P><H3><A NAME="HDRWQ471" HREF="auagd002.htm#ToC_555">예제 uss 템플릿</A></H3>
<P>이 절에서는 기본 및 전체 계정 유형에 대한 예제 템플릿(인증 전용 계정에
대한 템플릿은 비어 있음)을 설명합니다.
<P>첫 번째 예제는 기본 계정을 작성하는 것입니다. 여기에는 두 개의 <B>G</B> 명령어와 볼륨 이름, 파일 서버 시스템, 파티션 및 킬로바이트 단위의
할당량, 마운트 포인트, 홈 디렉토리 사용자 및 홈 디렉토리 액세스 제어 목록을
정의하는 <B>V</B> 명령어가 포함됩니다. Example Corporation
셀에서 적절한 템플릿은 다음과 같습니다.
<PRE>   G /afs/.example.com/usr1
   G /afs/.example.com/usr2
   V  user.$USER  $SERVER.example.com  /vicep$PART  5000  $AUTO/$USER   $UID  \
        $USER all staff rl
</PRE>
<P>이러한 유형의 템플릿에서 <B>uss add</B> 명령을 실행할 때는
다음 인수를 제공하십시오.
<UL>
<LI>$USER 변수에 대한 사용자 이름을 지정하기 위한 <B>-user</B>
</LI><LI>$SERVER 변수에 대한 파일 서버 시스템 이름의 고유한 부분을 지정하기
위한 <B>-server</B>
</LI><LI>$PART 변수에 대한 파티션 이름의 고유한 부분을 지정하기 위한
<B>-partition</B>
</LI></UL>
<P>보호 서버는 자동으로 $UID 변수에 대해 AFS UID를 지정하고
<B>G</B> 명령어는 $AUTO 변수의 값을 제공합니다.
<P>다음 예제 템플릿 파일은 Example Corporation 셀에 전체 계정을 작성합니다.
각 명령어 유형에 대한 다음 섹션은 예제의 결과를 설명합니다.
<B>V</B> 및 <B>E</B> 명령어는 쉽게 이해할 수
있게 하기 위해 두 개의 행에 표시되었다는 점을 알아 두십시오.
<PRE>   #
   # Specify the available grouping directories
   #
   G /afs/.example.com/usr1
   G /afs/.example.com/usr2
   #
   # Create the user's home volume
   #
   V user.$USER $SERVER.example.com /vicep$PART 5000 /afs/.example.com/$AUTO/$USER \
        $UID $USER all abc:staff rl
   #
   # Create directories and files for mail
   #
   D $MTPT/.MESSAGES 0700 $UID $USER all abc:staff none
   D $MTPT/.Outgoing 0700 $UID $USER rlidwk postman rlidwk
   D $MTPT/Mailbox 0700 $UID $USER all abc:staff none system:anyuser lik
   #
   # Here are some useful scripts for login etc.
   #
   F $MTPT/.Xbiff 0755 $UID /afs/example.com/admin/user/proto
   F $MTPT/.Xresources 0644 $UID /afs/example.com/admin/user/proto
   F $MTPT/.Xsession 0755 $UID /afs/example.com/admin/user/proto
   F $MTPT/.cshrc 0755 $UID /afs/example.com/admin/user/proto
   F $MTPT/.login 0755 $UID /afs/example.com/admin/user/proto
   F $MTPT/.logout 0755 $UID /afs/example.com/admin/user/proto
   F $MTPT/.twmrc 0644 $UID /afs/example.com/admin/user/proto
   F $MTPT/preferences 0644 $UID /afs/example.com/admin/user/proto
   #
   # Make a passwd entry
   #
   E /afs/.example.com/common/etc/newaccts/passwd_$USER 0644 root \
        "$USER:X:$UID:11:$NAME:$MTPT:/bin/csh"
   #
   # Put in the standard password/authentication checks
   #
   A $USER 250 noreuse 9 25
   #
   # Create and mount a public volume for the user
   #
   X "create_public_vol $USER $1 $2"
   #
   # Here we set up the symbolic link to public directory
   #
   S /afs/example.com/public/$USER $MTPT/public
</PRE>
<A NAME="IDX7638"></A>
<A NAME="IDX7639"></A>
<A NAME="IDX7640"></A>
<A NAME="IDX7641"></A>
<A NAME="IDX7642"></A>
<P><H3><A NAME="HDRWQ472" HREF="auagd002.htm#ToC_556">G 명령어를 사용하여 사용자 홈 디렉토리의 공평한 분배</A></H3>
<P>수천 개의 사용자 계정이 있는 셀에서 사용자 볼륨에 대한 마운트 포인트를 모두
한 디렉토리에 배치할 경우 사용자 홈 디렉토리가 액세스될 때 디렉토리 조회
속도가 상당히 느려지므로 이들 마운트 포인트를 여러 상위 디렉토리에 분배하는
것이 바람직한 경우가 종종 있습니다. 가능한 해결 방법은 사용자 홈 디렉토리를
알파벳 순서대로 그룹화하거나 학술 또는 기업 부문과 같은 부서를 나타내는
상위 디렉토리를 작성하는 것입니다. 그러나 실제로 대규모 셀에서는 이러한 몇몇
그룹이 여전히 너무 커서 디렉토리 조회 속도를 떨어뜨릴 수 있으므로 이러한
그룹에 속하는 사용자들은 자신의 홈 디렉토리를 액세스할 때마다 부당하게
불리한 조건에 처하게 됩니다. 작업장 부서를 나타내는 그룹화의 또 다른 맹점은
사용자가 부서 관계를 변경할 때 마운트 포인트를 옮겨야 한다는 것입니다.
<P>한 가지 대안은 작업장 부서를 나타내지 않는 여러 개의 상위
디렉토리로 사용자 홈 디렉토리를 공평하게 분배하는 것입니다.
<B>uss</B> 명령 집합을 사용하면 템플릿 파일의
맨 위에서 각각에 대해 <B>G</B> 명령어를 배치한
다음 <B>V</B> 명령어의 <VAR>mount_point</VAR>
필드에 $AUTO 변수를 사용하여 디렉토리 목록을 정의할 수
있습니다. <B>uss</B> 명령 인터프리터는 $AUTO
변수를 만나면 현재 가장 적은 수의 항목을 가지는
<B>G</B> 명령어에 의해 명명된 디렉토리를
대체합니다(실제로 $AUTO 변수는 명령어 유형에 관계없이 경로
이름을 포함하는 어떠한 필드에서도 나타날 수 있습니다.
모든 경우에서 명령 인터프리터는 현재 가장 적은 수의 항목을
가지고 있는 디렉토리를 대체합니다).
<P><B>G</B> 명령어 구문은 다음과 같습니다.
<PRE>   G  <VAR>directory</VAR>
</PRE>
<P>여기서 <VAR>directory</VAR>는 완전한 디렉토리 경로 이름이나 마지막 요소(디렉토리
자체)를 지정합니다. 이에 따라 <B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에 배치할 적절한 값이 결정됩니다.
<P>각 디렉토리로의 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 새 마운트 포인트를 작성하려고 할 때 발생할 수 있는 장애를 피하십시오.
일반적으로, 경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을
찍어 읽기/쓰기 경로를 표시합니다(예를 들어, <B>/afs/.example.com</B>). 파일 공간을 통한 읽기/쓰기와 읽기 전용
경로의 개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>예를 들어 <A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정에 대한 Example Corporation
예제 템플릿은 다음의 두 디렉토리를 정의합니다.
<PRE>   G /afs/.example.com/usr1
   G /afs/.example.com/usr2
</PRE>
<P>또한 <B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에
<B>$AUTO/$USER</B> 값을 추가합니다. 동일한 결과를 얻을 수
있는 또 다른 방법은 다음과 같이 디렉토리를 정의하는 것입니다.
<PRE>   G usr1
   G usr2
</PRE>
<P>그리고 <B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에
<B>/afs/.example.com/$AUTO/$USER</B>와 같은 완전한 경로 이름을
지정하십시오.
<A NAME="IDX7643"></A>
<A NAME="IDX7644"></A>
<A NAME="IDX7645"></A>
<A NAME="IDX7646"></A>
<A NAME="IDX7647"></A>
<A NAME="IDX7648"></A>
<P><H3><A NAME="HDRWQ473" HREF="auagd002.htm#ToC_557">V 명령어를 사용한 볼륨 작성</A></H3>
<P>템플릿 파일이 비어 있지 (0길이) 않은 한 이 파일 안에는
하나의 <B>V</B> 명령어만 나타나야
합니다(<B>uss</B> 계정 작성 조작의 일부로
사용자에 대해 다른 볼륨을 작성하려면 <B>X</B>
명령어를 사용하여 <B>vos create</B> 명령 또는
<B>fs mkmount</B> 명령과 같이 다른 명령과
함께 이 vos create 명령을 호출하는 스크립트를 호출하십시오.
예를 들어 <A HREF="#HDRWQ479">X 명령어를 사용하여 명령 실행</A>을 참조하십시오).
<P><B>V</B> 명령어는 다음 AFS 엔티티를 정의합니다.
<UL>
<LI>볼륨 및 연관된 VLDB 항목
</LI><LI>볼륨의 사이트(파일 서버 시스템 및 파티션)
</LI><LI>사용자의 홈 디렉토리가 되는 AFS 파일 공간에 있는 볼륨의 마운트 포인트
</LI><LI>볼륨의 공간 할당량
</LI><LI>보통 새로운 사용자가 되는 홈 디렉토리의 소유자
</LI><LI>보통 사용자에게 모든 권한을 부여하는 홈 디렉토리의 ACL
</LI></UL>
<P><B>V</B> 명령어의 필드에 대한 다음 설명은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿에 나오는
예제를 참조합니다(여기에서는 읽기 편리하도록 명령어를
두 행으로 나타난 것에 불과함).
<PRE>   V  user.$USER  $SERVER.example.com  /vicep$PART  5000  \
       /afs/.example.com/$AUTO/$USER  $UID  $USER all abc:staff rl
</PRE>
<P><B>V</B> 명령어의 구문은 다음과 같습니다.
<PRE>   V  <VAR>volume_name</VAR>  <VAR>server</VAR>  <VAR>partition</VAR>  <VAR>quota</VAR>  <VAR>mount_point</VAR> <VAR>owner</VAR>  <VAR>ACL</VAR>
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>V</B>
</B><DD>볼륨 작성 명령어를 나타냅니다.
<P><DT><B><VAR>volume_name</VAR>
</B><DD>VLDB에 기록된 것처럼 볼륨의 이름을 지정합니다.
<P>
<P>사용자 이름을 볼륨 이름의 일부로 포함시키는 규칙을 따르려면 이 필드에
$USER 변수를 포함시키십시오. 이 변수는 <B>uss add</B> 명령에
대한 <B>-user</B> 인수에서 또는 벌크 입력 파일
<B>add</B> 명령어의 <VAR>username</VAR> 필드에서 그 값을
취합니다.
<P>
<P>Example Corporation 예제에서는 값 <B>user.$USER</B>를 사용하여
일반적인 볼륨 이름, <B>user.</B><VAR>username</VAR>을
지정합니다. 예를 들어 사용자 <B>smith</B>에 대한 계정을
작성할 때는 <B>-user smith</B>를 <B>uss add</B>
명령에 대한 인수로 포함시키거나 벌크 입력 파일 <B>add</B> 명령어의 <VAR>username</VAR> 필드에 값 <B>smith</B>를
추가하십시오.
<P><DT><B><VAR>server</VAR>
</B><DD>새 볼륨을 작성할 파일 서버 시스템을 명명합니다. 완전 규정화된 호스트 이름(예:
<B>fs1.example.com</B>)을 제공하는 것이 가장 바람직하지만
셀의 명명 서비스를 사용하여 볼륨이 작성될 때 약어 형태를 해석할 수 있으면
약어 형태도 허용됩니다.
<P>
<P>다른 파일 서버 시스템에 다른 사용자의 볼륨을 배치하려면 이 필드에
$SERVER 변수를 사용하고 <B>uss add</B> 명령의
<B>-server</B> 인수를 사용해서 또는 벌크 입력 파일
<B>add</B> 명령어의 <VAR>server</VAR> 필드에서 $SERVER 변수의
값을 제공하십시오. 명령행에 완전 규정화된 호스트 이름을 그대로 입력하지
않고도 이 이름을 지정하는 쉬운 방법은 상수 및 $SERVER 변수를 조합해서
사용하는 것입니다. 특히 상수는 모든 파일 서버 시스템에 공통적으로 적용되는
도메인 이름 접미어를 지정합니다.
<P>
<P>Example Corporation 예제에서 셀의 모든 파일 서버 시스템은 <B>example.com</B> 도메인 이름 접미어를 공유하므로 <VAR>server</VAR> 필드는
<B>$SERVER.example.com</B>와 같이 변수와 상수를 조합합니다.
시스템 <B>fs1.example.com</B>에 새 볼륨을 배치하려면
<B>-server fs1</B>을 <B>uss add</B> 명령에 대한
인수로 포함시키거나 벌크 입력 파일 <B>add</B> 명령어의
<VAR>server</VAR> 필드에 값 <B>fs1</B>을 추가하십시오.
<P><DT><B><VAR>partition</VAR>
</B><DD>사용자 볼륨을 작성할 파티션을 지정합니다. 이 파티션은 <VAR>server</VAR>
필드에 명명된 파일 서버 시스템에 있어야 합니다. 그 완전한 이름(예:
<B>/vicepa</B>)으로 파티션을 식별하거나 <A HREF="auagd023.htm#HDRWQ615">약어 및 별명 사용 규칙</A>에
나열된 약어 중 하나를 사용하십시오.
<P>
<P>다른 파티션에 다른 사용자의 볼륨을 배치하려면 이 필드에
$PART 변수를 사용하고 <B>uss add</B> 명령의
<B>-partition</B> 인수를 사용해서 또는 벌크 입력 파일
<B>add</B> 명령어의 <VAR>partition</VAR> 필드에서 $PART 변수의
값을 제공하십시오. 모든 파티션 이름이 <B>/vicep</B> 문자열로
시작되므로 이 문자열을 상수로서 $PART 변수와 함께 조합하는 것이 편리한 방법입니다.
<P>
<P>Example Corporation 예제 템플릿은 <B>/vicep$PART</B>와 같이
상수 문자열 <B>/vicep</B>를 $PART 변수와 조합합니다.
<A NAME="IDX7649"></A>
<A NAME="IDX7650"></A>
<A NAME="IDX7651"></A>
<A NAME="IDX7652"></A>
<P><DT><B><VAR>quota</VAR>
</B><DD>블록이 파일 서버 시스템의 디스크에서 차지할 수 있는 킬로바이트 블록의
최대 수를 설정합니다. 이것은 정수여야 합니다. 모든 사용자 볼륨에 동일한
할당량을 지정하려면 상수 값을 지정하십시오. 다른 볼륨에 다른 할당량을 지정하려면
이 필드에 숫자 변수($1 - $9) 중 하나를 입력하고 <B>uss add</B>
명령에 대한 <B>-var</B> 인수를 사용해서 또는 벌크 입력 파일
<B>add</B> 명령어의 해당 필드에 그 값을 제공하십시오.
<P>
<P>Example Corporation 예제는 새로운 모든 사용자에게 5000 KB의 초기 할당량을 부여합니다.
<A NAME="IDX7653"></A>
<A NAME="IDX7654"></A>
<A NAME="IDX7655"></A>
<A NAME="IDX7656"></A>
<P><DT><B><VAR>mount_point</VAR>
</B><DD>볼륨의 루트 디렉토리 및 사용자의 홈 디렉토리로 작동하는 볼륨에 대한
마운트 포인트를 작성합니다. 일반적으로 사용자 홈 디렉토리 이름에는
이 필드에 $USER 변수를 포함시켜 읽을 수 있는 사용자 이름이 포함됩니다.
<P>
<P>읽기 전용 볼륨에서 새 마운트 포인트를 작성하려고 할 때
실패하지 않도록 마운트 포인트까지의 읽기/쓰기 경로를
지정하십시오. 일반적으로, 경로 이름의 두 번째 레벨에서
셀 이름 앞에 점을 찍어 읽기/쓰기 경로를 표시합니다(예를
들어, <B>/afs/.example.com</B>). 이 필드에 $AUTO
변수를 사용하는 경우 각 <B>G</B> 명령어에서
명명하는 디렉토리는 이미 읽기/쓰기 경로를 나타내고 있을
것입니다. 파일 공간을 통한 읽기/쓰기와 읽기 전용 경로의
개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>
<P>마운트 포인트 이름의 다른 부분도 사용자마다 다른 경우 이 필드에 $MTPT 변수를
사용하고 <B>uss add</B> 명령의 <B>-mount</B>
인수를 사용해서 또는 벌크 입력 파일 <B>add</B> 명령어의
<VAR>mount_point</VAR> 필드에 값을 제공할 수 있습니다. 그러나 템플릿의
다음 명령어에 $MTPT 변수가 나타나면 (보통 <B>D</B>, <B>E</B> 또는 <B>F</B> 명령어에서)
이 변수는 이 필드의 전체 내용을 그 값으로 취합니다.
<P>
<P>하나 이상의 상위 디렉토리에 홈 디렉토리를 함께 그룹화하는 것에 대해 내린
결정에 따라 상수와 변수를 조합하십시오. 템플릿을 참조하는 <B>uss add</B>
또는 <B>uss bulk</B> 명령을 실행하기 전에 이 상위 디렉토리가
이미 있어야 합니다. 홈 디렉토리 그룹화의 다양한 방법은 다음과 같습니다.
<A NAME="IDX7657"></A>
<P>
<UL>
<LI>단일 상위 디렉토리에 모든 사용자 홈 디렉토리 배치하기.
이름 <B>/afs/</B><VAR>cellname</VAR><B>/usr</B>은
UNIX <B>/usr</B> 규칙을 AFS에 맞게 변형한 것입니다.
이 방법은 소수의 사용자 계정이 있는 셀에 가장 적절합니다. 이 방법을 구현하는
가장 쉬운 방식은 <B>/afs/.example.com/usr/$USER</B>와 같이 상수
문자열과 $USER 변수와 조합하는 것입니다.
</LI><LI>작업장 부서에 해당하지 않는 상위 디렉토리 집합으로 공평하게 홈 디렉토리를
분배. 이 방법은 수만 개의 계정이 있는 셀에서 적절합니다. 여기에서 모든 홈
디렉토리가 하나의 상위 디렉토리에 있는 경우 홈 디렉토리의 수가 많아서
디렉토리 조회가 상당히 느려질 수 있으나 작업장 부서에 따른 분배는 타당하지
않습니다.
<P>
<P>$AUTO 변수는 이 방식으로 공평하게 홈 디렉토리를 분배할 수 있도록
설계되었습니다. <A HREF="#HDRWQ472">G 명령어를 사용하여 사용자 홈 디렉토리의 공평한 분배</A>에서 설명하는 것처럼 <B>uss</B>
명령 인터프리터는 <B>G</B> 템플릿 명령어를 앞에 사용함으로써
정의되었으며 현재 가장 적은 수의 항목을 가지고 있는 디렉토리를 대체합니다.
예제 Example Corporation 템플릿은 값 <B>/afs/.example.com/$AUTO/$USER</B>를
사용하여 이 방법을 보여줍니다.
</LI><LI>학술 또는 기업 부서를 반영하는 여러 디렉토리로 홈 디렉토리 분배.
이 설계 방식을 구현하는 가장 쉬운 방법은 <B>/afs/.example.com/usr/$MTPT/$USER</B>에서처럼
$MTPT 변수를 사용하여 부서를 나타내는 것입니다. 그런 다음 <B>-user smith</B> 및 <B>-mount acctg</B> 인수를
<B>uss add</B> 명령에 제공하여 마운트 포인트 <B>/afs/.example.com/usr/acctg/smith</B>를 작성해야 합니다.
</LI><LI>홈 디렉토리를 사용자 이름의 처음 한 문자 또는 여러 문자에 따라
<B>usr</B>의 알파벳 하위 디렉토리
순서(<B>usr/a</B>, <B>usr/b</B> 등)로
분배. 이 방법의 이점은 사용자 이름을 알 경우 홈 디렉토리를 쉽게 찾을 수
있다는 것입니다. 있을 수 있는 단점은 분배가 균일해지지 못할 수 있으며
많은 수의 계정이 있을 경우 디렉토리 조회가 느려져서 그 이름이 자주 사용되는
문지로 시작되는 사용자의 이름을 사용할 때 문제가 생긴다는 것입니다.
<P>
<P>이 설계 방식을 구현하는 가장 쉬운 방법은 <B>/afs/.example.com/usr/$MTPT/$USER</B>에서처럼
$MTPT 변수를 사용하여 문자 또는 여러 문자를 나타내는 것입니다.
그런 다음 <B>-user smith</B> 및 <B>-mount
s/m</B> 인수를 <B>uss add</B> 명령에 제공하여 마운트 포인트
<B>/afs/.example.com/usr/s/m/smith</B>를 작성하는 것입니다.
</LI></UL>
<P><DT><B><VAR>owner</VAR>
</B><DD>UNIX <B>ls -ld</B> 명령의 출력에 사용자의
사용자 이름 또는 UID가 마운트 포인트의 소유자로 지정되도록
지정합니다. 홈 디렉토리 소유권에 대한 표준 규칙을 따르려면
Example Corporation 예제 템플릿에서처럼 이 필드에서 $UID 변수를
사용하십시오. 그러면 보호 서버는 사용자가
<B>-uid</B> 인수를 <B>uss add</B>
명령에 제공하거나 벌크 입력 파일 <B>add</B>
명령어에서 <VAR>uid</VAR> 필드를 채우지 않는 한 자동으로 AFS
UID를 지정합니다(기존의 UNIX 계정을 변환하는 경우
<A HREF="#HDRWQ459">uss를 사용한 기존 UNIX 계정 변환</A>의 추가 고려사항에 대한
설명을 참조하십시오).
<A NAME="IDX7658"></A>
<A NAME="IDX7659"></A>
<A NAME="IDX7660"></A>
<A NAME="IDX7661"></A>
<P><DT><B><VAR>ACL</VAR>
</B><DD>새 홈 디렉토리에 ACL을 설정합니다. 각각이 AFS 사용자
이름이나 그룹 이름으로 구성되고 해당 순서대로 권한이 부여된
하나 이상의 쌍을 이룬 값을 제공하십시오(그룹 이름은 사용될
보호 데이터베이스에 이미 있어야 함). 쌍 내의 두 값과 쌍들간은
공백으로 분리하십시오. 사용할 수 있는 권한에 대한 설명은
<A HREF="auagd020.htm#HDRWQ567">AFS ACL 권한</A>을 참조하십시오.
<P>
<P>최소한 이 필드에 값 <B>$USER all</B>을 포함시켜
새 사용자에게 모든 권한을 부여하십시오. 파일 서버는
<B>system:administrators</B> 그룹에도 모든
권한을 자동으로 부여합니다. 계정 작성의 마지막 단계에서
<B>uss</B> 명령 인터프리터는 작성 프로세스중에
설정된 ACL에서 <B>uss</B> 명령의 실행자를
자동으로 삭제하므로 이 사용자에게 권한을 부여할 수 없습니다.
<P>
<P>Example Corporation 예제에서는 다음 값을 사용하여 새로운 사용자에게
모든 권한을 부여하고 <B>abc:staff</B> 그룹의
구성원에게 <B>r</B>(<B>읽기</B>) 및
<B>l</B>(<B>조회</B>) 권한을 부여합니다.
<P>
<P><B>$USER all abc:staff rl</B>
</DL>
<A NAME="IDX7662"></A>
<A NAME="IDX7663"></A>
<A NAME="IDX7664"></A>
<A NAME="IDX7665"></A>
<A NAME="IDX7666"></A>
<A NAME="IDX7667"></A>
<P><H3><A NAME="HDRWQ474" HREF="auagd002.htm#ToC_558">D 명령어를 사용하여 디렉토리 작성</A></H3>
<P>템플릿 파일의 각 <B>D</B> 명령어는 디렉토리를
작성합니다. 템플릿에서 이 명령어의 수에는 제한이 없습니다.
<B>D</B> 명령어가 새로운 사용자 홈 디렉토리에
하위 디렉토리를 작성하는 경우 <B>V</B> 명령어
뒤에 사용되어야 합니다. <B>uss</B> 명령이 실행되는
시스템의 로컬 디스크에 디렉토리를 작성하는 것은
<A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>에서 설명하는 여러 가지 이유로 인해
권장되지 않습니다.
<P><B>D</B> 명령어의 필드에 대한 다음 설명은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿의 예제 중
하나를 참조합니다.
<PRE>   D $MTPT/Mailbox 0700 $UID $USER all abc:staff none  system:anyuser lik
</PRE>
<P><B>D</B> 명령어 구문은 다음과 같습니다.
<PRE>   D  <VAR>pathname</VAR>  <VAR>mode_bits</VAR>  <VAR>owner</VAR>  <VAR>ACL</VAR>
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>D</B>
</B><DD>디렉토리 작성 명령어를 나타냅니다.
<P><DT><B><VAR>pathname</VAR>
</B><DD>디렉토리의 전체 경로 이름을 지정합니다. 이것이 사용자
홈 디렉토리의 하위 디렉토리이면 $MTPT 변수를 사용하여 홈
디렉토리 경로 이름을 지정하는 것이 가장 간단합니다. $MTPT
변수는 <B>D</B> 명령어에 나타나면 이전
<B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에서
그 값을 취합니다(이러한 종속성을 보면 <B>D</B>
명령어가 <B>V</B> 명령어 다음에 나와야 하는
이유를 알 수 있습니다).
<P>
<P>디렉토리로의 읽기/쓰기 경로 이름을 지정하여 읽기 전용 볼륨에서
새 디렉토리를 작성하려고 할 때 발생할 수 있는 장애를 피하십시오.
일반적으로, 경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을
찍어 읽기/쓰기 경로를 표시합니다(예를 들어,
<B>/afs/.example.com</B>). 이 필드에 $MTPT 변수를
사용하는 경우 각 <B>V</B> 명령어의
<VAR>mount_point</VAR> 필드의 값은 이미 읽기/쓰기 경로를 나타내고
있을 것입니다. 파일 공간을 통한 읽기/쓰기와 읽기 전용 경로의
개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>
<P>Example Corporation 예제에서는 값 <B>$MTPT/Mailbox</B>를
사용하여 사용자의 홈 디렉토리에 <B>Mailbox</B> 하위
디렉토리를 배치합니다.
<P><DT><B><VAR>mode_bits</VAR>
</B><DD>디렉토리의 UNIX 모드 비트를 정의합니다. 허용되는 값은
권한 조합에 따라 표준 3자리 또는 4자리 숫자입니다. 예제:
<B>0755</B>는 <B>rwxr-xr-x</B>에
해당하고 <B>0644</B>는 <B>rw-r--r--</B>에
해당합니다. 첫째(소유자) <B>x</B> 비트는
액세스로의 액세스를 허용하기 위해 설정되어 있어야 합니다.
<P>
<P>Example Corporation 예제는 값 <B>0700</B>을 사용하여
<B>Mailbox</B> 하위 디렉토리의 모드 비트를
<B>rwxr-----</B>로 설정합니다.
<P><DT><B><VAR>owner</VAR>
</B><DD>UNIX <B>ls -ld</B> 명령의 출력에서
사용자의 사용자 이름이나 UID가 디렉토리의 소유자로
지정되도록 지정합니다.
<P>
<P>이 디렉토리가 AFS에 위치하는 경우 Example Corporation 예제
템플릿에서 처럼 이 필드에 $UID 변수를 추가하십시오. 그러면
보호 서버는 사용자가 <B>-uid</B> 인수를
<B>uss add</B> 명령에 제공하거나 벌크 입력
파일 <B>add</B> 명령어에서 <VAR>uid</VAR>
필드를 채우지 않는 한 자동으로 AFS UID를 지정합니다(기존의
UNIX 계정을 변환하는 경우 <A HREF="#HDRWQ459">uss를 사용한 기존 UNIX 계정 변환</A>의
추가 고려사항에 대한 설명을 참조하십시오).
<P>
<P>디렉토리가 로컬 디스크에 있으면 <B>uss</B> 명령을
실행하고 있는 사용자 이름이나 UNIX UID를 지정하는 것이 가장 쉬운
방법입니다. 다른 사용자를 지정할 때 발생하는 문제에 대해서는
<A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>를 참조하십시오.
<A NAME="IDX7668"></A>
<A NAME="IDX7669"></A>
<A NAME="IDX7670"></A>
<A NAME="IDX7671"></A>
<P><DT><B><VAR>ACL</VAR>
</B><DD>새 디렉토리에 ACL을 설정합니다. 각각이 AFS 사용자
이름이나 그룹 이름으로 구성되고 해당 순서대로 권한이 부여된
하나 이상의 쌍을 이룬 값을 제공하십시오(그룹 이름은 사용될
보호 데이터베이스에 이미 있어야 함). 쌍 내의 두 값과 쌍들간은
공백으로 분리하십시오. 사용할 수 있는 권한에 대한 설명은
<A HREF="auagd020.htm#HDRWQ567">AFS ACL 권한</A>을 참조하십시오.
<P>
<P>최소한 값 <B>$USER all</B>을 포함시켜
새 사용자에게 모든 권한을 부여하십시오. 계정 작성의 마지막
단계에서 <B>uss</B> 명령 인터프리터는 작성
프로세스중에 설정된 ACL에서 <B>uss</B> 명령의
실행자를 자동으로 삭제하므로 이 사용자에게 권한을 부여할 수
없습니다. 디렉토리가 로컬 디스크에 있는 경우
<A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>에서 자세히 설명하는 것처럼
항상 오류 메시지가 발생합니다.
<P>
<P>Example Corporation 예제에서는 다음 값을 사용하여 새로운 사용자에게
모든 권한을 부여하고 <B>abc:staff</B> 그룹의
구성원에게 어떠한 권한도 부여하지 않고
<B>system:anyuser</B>의 구성원에게
<B>l</B>(<B>조회</B>),
<B>i</B>(<B>삽입</B>) 및
<B>k</B>(<B>잠금</B>) 권한을
부여합니다.
<P>
<P><B>$USER all abc:staff none system:anyuser lik</B>
<P>
<P>이러한 확장된 권한을 <B>system:anyuser</B> 그룹에
부여하여 시스템 사용자(메일 전달 디먼)가 <B>Mailbox</B>
디렉토리에 메일을 삽입할 수 있게 합니다. <B>r</B>(<B>읽기</B>)
권한이 없으면 <B>system:anyuser</B> 그룹의
구성원은 메일 파일을 읽을 수 없습니다.
</DL>
<A NAME="IDX7672"></A>
<A NAME="IDX7673"></A>
<A NAME="IDX7674"></A>
<A NAME="IDX7675"></A>
<A NAME="IDX7676"></A>
<A NAME="IDX7677"></A>
<P><H3><A NAME="HDRWQ475" HREF="auagd002.htm#ToC_559">F 명령어를 사용하여 프로토타입에서 파일 작성</A></H3>
<P>템플릿 파일의 각 <B>F</B> 명령어는 기존의 프로토타입 파일
내용을 복사하여 파일을 작성합니다. 템플릿에서 이 명령어의 수에는 제한이 없으며
각 명령어가 다른 프로토타입을 참조할 수 있습니다.
<B>F</B> 명령어가 새 사용자의 디렉토리나 하위 디렉토리를
작성하는 경우 이 명령어는 상위 디렉토리를 작성하는 <B>V</B>
또는 <B>D</B> 명령어 다음에 나와야 합니다. <B>uss</B>
명령이 실행되는 시스템의 로컬 디스크에서 파일을 작성하는 것은
<A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>에서 설명하는 여러 가지 이유로 인해 권장되지 않습니다.
<P><B>E</B> 명령어도 파일을 작성하지만 두 가지 유형의 명령어는
상호 보완적인 이점을 제공합니다. <B>E</B> 명령어로 작성한
파일은 파일을 내용을 지정하는 필드에 나타날 수 있으므로 각 사용자에 맞게
사용자 정의할 수 있습니다. 반대로 <B>F</B> 명령어를
사용하여 작성된 파일의 내용은 모든 사용자에게 동일합니다. 그러나
<B>E</B> 파일은 단일 행에만 사용할 수 있고
<B>F</B> 파일은 길이 제한이 없습니다.
<P><B>F</B> 명령어의 필드에 대한 다음 설명은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿의 예제 중 하나를 참조합니다.
<PRE>   F $MTPT/.login 0755 $UID /afs/example.com/admin/user/proto
</PRE>
<P><B>F</B> 명령어의 구문은 다음과 같습니다.
<PRE>   F  <VAR>pathname</VAR>  <VAR>mode_bits</VAR>  <VAR>owner</VAR>  <VAR>prototype_file</VAR>
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>F</B>
</B><DD>파일 작성 명령어를 나타냅니다.
<P><DT><B><VAR>pathname</VAR>
</B><DD>파일 이름을 포함하여 작성할 파일의 전체 경로 이름을
지정합니다. 이것이 사용자 홈 디렉토리나 그 하위 디렉토리에
있으면 $MTPT 변수를 사용하여 홈 디렉토리 경로 이름을 지정하는
것이 가장 간단합니다. $MTPT 변수는 <B>F</B>
명령어에 나타나면 이전 <B>V</B> 명령어의
<VAR>mount_point</VAR> 필드에서 그 값을 취합니다(이러한 종속성을
보면 <B>F</B> 명령어가 <B>V</B>
명령어 다음에 나와야 하는 이유를 알 수 있습니다).
<P>
<P>파일로의 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 새 파일을
작성하려고 할 때 발생할 수 있는 장애를 피하십시오. 일반적으로,
경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을 찍어 읽기/쓰기
경로를 표시합니다(예를 들어, <B>/afs/.example.com</B>).
이 필드에 $MTPT 변수를 사용하는 경우 각 <B>V</B>
명령어의 <VAR>mount_point</VAR> 필드의 값은 이미 읽기/쓰기 경로를
나타내고 있을 것입니다. 파일 공간을 통한 읽기/쓰기와 읽기 전용
경로의 개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>
<P>Example Corporation 예제에서는 값 <B>$MTPT/.login</B>을
사용하여 사용자의 홈 디렉토리에 <B>.login</B>이라는
파일을 배치합니다.
<P><DT><B><VAR>mode_bits</VAR>
</B><DD>파일의 UNIX 모드 비트를 정의합니다. 허용되는 값은 권한 조합에
따라 표준 3자리 또는 4자리 숫자입니다.
예제: <B>0755</B>는 <B>rwxr-xr-x</B>에
해당하고 <B>0644</B>는 <B>rw-r--r--</B>에
해당합니다.
<P>
<P>Example Corporation 예제는 값 <B>0755</B>를 사용하여
<B>.login</B> 파일에 대한 모드 비트를 <B>rwxr-xr-x</B>로 설정합니다.
<P><DT><B><VAR>owner</VAR>
</B><DD>UNIX <B>ls -l</B> 명령의 출력에서 사용자의 사용자 이름이나
UID가 파일의 소유자로 지정되도록 지정합니다.
<P>
<P>이 파일이 AFS에 위치하는 경우 Example Corporation 예제 템플릿에서
처럼 이 필드에 $UID 변수를 추가하십시오. 그러면 보호 서버는
사용자가 <B>-uid</B> 인수를
<B>uss add</B> 명령에 제공하거나 벌크 입력 파일
<B>add</B> 명령어에서 <VAR>uid</VAR> 필드를
채우지 않는 한 자동으로 AFS UID를 지정합니다(기존의 UNIX
계정을 변환하는 경우 <A HREF="#HDRWQ459">uss를 사용한 기존 UNIX 계정 변환</A>의 추가
고려사항에 대한 설명을 참조하십시오).
<P>
<P>파일이 로컬 디스크에 있으면 <B>uss</B> 명령을
실행하고 있는 사용자 이름이나 UNIX UID를 지정하는 것이 가장
쉬운 방법입니다. 다른 사용자를 지정할 때 발생하는 문제에
대해서는 <A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>를 참조하십시오.
<P><DT><B><VAR>prototype_file</VAR>
</B><DD>복사할 프로토타입 파일이 있는 AFS 또는 로컬 디렉토리를 명명합니다.
프로토타입 파일의 이름은 <VAR>pathname</VAR> 필드의 마지막 요소와 일치해야 합니다.
<P>
<P>Example Corporation 예제는 디렉토리 <B>/afs/example.com/admin/user/proto</B>에
있는 <B>.login</B>이라는 프로토타입 파일을 참조합니다.
</DL>
<A NAME="IDX7678"></A>
<A NAME="IDX7679"></A>
<A NAME="IDX7680"></A>
<A NAME="IDX7681"></A>
<A NAME="IDX7682"></A>
<A NAME="IDX7683"></A>
<P><H3><A NAME="HDRWQ476" HREF="auagd002.htm#ToC_560">E 명령어를 사용하여 한 행 파일 작성</A></H3>
<P>템플릿 파일의 각 <B>E</B> 명령어는 지정된 단일 행을 에코하여
파일을 작성합니다. 템플릿에서 이 명령어의 수에는 제한이 없습니다.
<B>E</B> 명령어가 새 사용자의 디렉토리나 하위 디렉토리에 파일을
작성하는 경우 이 명령어는 상위 디렉토리를 작성하는 <B>D</B>
명령어 다음에 나와야 합니다. <B>uss</B>
명령이 실행되는 시스템의 로컬 디스크에서 파일을 작성하는 것은
<A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>에서 설명하는 여러 가지 이유로 인해 권장되지 않습니다.
<P><B>F</B> 명령어도 파일을 작성하지만 두 가지 유형의 명령어는
상호 보완적인 이점을 제공합니다. <B>E</B> 명령어로 작성한
파일은 파일을 내용을 지정하는 필드에 나타날 수 있으므로 각 사용자에 맞게
사용자 정의할 수 있습니다. 이 명령 인터프리터는 파일을 작성하기 전에
변수를 적절한 값으로 바꿉니다. 반대로 <B>F</B> 명령어를
사용하여 작성된 파일의 내용은 모든 사용자에게 동일합니다. 그러나
<B>E</B> 파일은 단일 행에만 사용할 수 있고
<B>F</B> 파일은 길이 제한이 없습니다.
<P><B>E</B> 명령어는 셀의 공통 원본 암호 파일에서 새 사용자에
대한 항목을 작성하는 데 특히 적절하며 이 항목은 클라이언트 시스템에 복사되어
로컬 암호 파일(<B>/etc/passwd</B> 또는 동급)로 사용됩니다.
필드에 대한 다음 설명은 <A HREF="#HDRWQ471">예제 uss 템플릿</A>에 나오는 Example Corporation의
전체 계정 템플릿에서 사용된 이러한 유형의 방식을 참조합니다. 이러한 방식으로
작성된 파일을 공통 원본 암호 파일에 통합하는 방법에 대한 자세한 설명을
보려면 <A HREF="#HDRWQ458">공통 원본 암호 파일 작성</A>을 참조하십시오.
<PRE>   E /afs/.example.com/common/etc/newaccts/passwd_$USER 0644 root \
        "$USER:X:$UID:11:$NAME:$MTPT:/bin/csh"
</PRE>
<P><B>E</B> 명령어의 구문은 다음과 같습니다.
<PRE>   E  <VAR>pathname</VAR>  <VAR>mode_bits</VAR>  <VAR>owner</VAR>  "<VAR>contents</VAR>"
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>E</B>
</B><DD>파일 작성 명령어를 나타냅니다.
<P><DT><B><VAR>pathname</VAR>
</B><DD>파일 이름을 포함하여 작성할 파일의 전체 경로 이름을
지정합니다. 여기에는 변수가 포함될 수 있습니다. 이것이
사용자 홈 디렉토리나 그 하위 디렉토리에 있으면 $MTPT 변수를
사용하여 홈 디렉토리 경로 이름을 지정하는 것이 가장
간단합니다. $MTPT 변수는 <B>E</B> 명령어에
나타나면 이전 <B>V</B> 명령어의
<VAR>mount_point</VAR> 필드에서 그 값을 취합니다(이러한 종속성을
보면 <B>E</B> 명령어가 <B>V</B>
명령어 다음에 나와야 하는 이유를 알 수 있습니다).
<P>
<P>파일로의 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 새 파일을
작성하려고 할 때 발생할 수 있는 장애를 피하십시오. 일반적으로,
경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을 찍어 읽기/쓰기
경로를 표시합니다(예를 들어, <B>/afs/.example.com</B>).
이 필드에 $MTPT 변수를 사용하는 경우 각 <B>V</B>
명령어의 <VAR>mount_point</VAR> 필드의 값은 이미 읽기/쓰기 경로를
나타내고 있을 것입니다. 파일 공간을 통한 읽기/쓰기와 읽기 전용
경로의 개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>
<P>Example Corporation 예제는 <B>E</B> 명령어에 의해 작성된 파일을
<B>/afs/.example.com/common/etc/newaccts</B> 디렉토리에 쓰고
새로운 사용자 이름 다음에 이를 명명합니다.
<PRE>   /afs/.example.com/common/etc/newaccts/passwd_$USER
</PRE>
<P><DT><B><VAR>mode_bits</VAR>
</B><DD>파일의 UNIX 모드 비트를 정의합니다. 허용되는 값은 권한 조합에
따라 표준 3자리 또는 4자리 숫자입니다.
예제: <B>0755</B>는 <B>rwxr-xr-x</B>에
해당하고 <B>0644</B>는 <B>rw-r--r--</B>에
해당합니다.
<P>
<P>Example Corporation 예제는 값 <B>0644</B>를 사용하여
<B>passwd_</B><VAR>user</VAR> 파일에 대한 모드 비트를
<B>r-xr--r--</B>로 설정합니다.
<P><DT><B><VAR>owner</VAR>
</B><DD>UNIX <B>ls -l</B> 명령의 출력에서 사용자의 사용자 이름이나
UID가 파일의 소유자로 지정되도록 지정합니다.
<P>
<P>이 파일이 AFS에 위치하고 해당 사용자가 소유하는 경우
이 필드에 $UID 변수를 추가하십시오. 그러면 보호 서버는
사용자가 <B>-uid</B> 인수를
<B>uss add</B> 명령에 제공하거나 벌크
입력 파일 <B>add</B> 명령어에서
<VAR>uid</VAR> 필드를 채우지 않는 한 자동으로 AFS UID를
지정합니다(기존의 UNIX 계정을 변환하는 경우
<A HREF="#HDRWQ459">uss를 사용한 기존 UNIX 계정 변환</A>의 추가 고려사항에 대한
설명을 참조하십시오).
<P>
<P>파일이 로컬 디스크에 있으면 <B>uss</B> 명령을 실행하고
있는 사용자 이름이나 UNIX UID를 지정하십시오.
다른 사용자를 지정할 때 발생하는 문제에 대해서는 <A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>를
참조하십시오.
<P>
<P>Example Corporation 예제는 새로운 사용자가 직접 사용하기 보다는 공통 암호
파일에 통합하기 위해 AFS 파일을 작성합니다. 따라서 로컬 수퍼유저
<B>루트</B>를 새 파일의 소유자로 지정합니다. AFS 파일에
대체 소유자를 지정하면 다음과 같은 복잡한 문제가 발생합니다.
AFS 파일에 대해 <B>chown</B> 명령을 실행하면
<B>system:administrators</B> 그룹에서 멤버쉽이 필요하지만
<B>uss</B> 명령의 실행자는 이 그룹의 구성원으로 반드시 인증을
받아야 합니다.
<P><DT><B><VAR>contents</VAR>
</B><DD>새 파일에 기록할 단일 행 문자 스트링을 지정합니다. 하나 이상의 공백이
포함되어 있는 경우 큰 따옴표(")로 묶으십시오. 개행 문자를 포함할 수 없으나
명령 인터프리터가 파일을 작성할 때 확인하는 표준 변수는 포함할 수 있습니다.
<P>
<P>Example Corporation 예제는 암호 파일 항목을 작성하기 위해 <VAR>contents</VAR>
필드에 다음 값을 포함하고 있습니다.
<PRE>   $USER:X:$UID:10:$NAME:$MTPT:/bin/csh
</PRE>
</DL>
<A NAME="IDX7684"></A>
<A NAME="IDX7685"></A>
<A NAME="IDX7686"></A>
<A NAME="IDX7687"></A>
<A NAME="IDX7688"></A>
<A NAME="IDX7689"></A>
<A NAME="IDX7690"></A>
<A NAME="IDX7691"></A>
<A NAME="IDX7692"></A>
<A NAME="IDX7693"></A>
<A NAME="IDX7694"></A>
<P><H3><A NAME="HDRWQ477" HREF="auagd002.htm#ToC_561">L 및 S 명령어를 사용한 연결 작성</A></H3>
<P>템플릿 파일의 각 <B>L</B> 명령어는 표준 UNIX
<B>ln</B> 명령을 사용하여 수행할 수 있는 것처럼
두 개의 파일간의 하드 연결을 작성합니다. <B>S</B>
명령어는 UNIX <B>ln -s</B> 명령을 사용하여 수행할
수 있는 것처럼 두 개의 파일간의 기호 연결을 작성합니다. 연결에
대한 설명은 이 문서에서 다루고 있지 않으나 두 가지 경우에 나타나는
기본적인 효과는 기존 파일에 대해 또 다른 이름을 작성하는 것과
같으므로 이름을 통해 액세스할 수 있습니다. 연결을 작성한다고
해서 파일의 또 다른 사본이 작성되는 것은 아닙니다.
<P>템플릿 파일에서 <B>L</B> 또는
<B>S</B> 명령어 수에는 제한이 없습니다. 링크가
새로운 사용자의 홈 디렉토리나 하위 디렉토리에 있으면 상위
디렉토리를 작성하는 <B>V</B> 또는
<B>D</B> 명령어와 연결될 파일을 작성하는
<B>F</B>, <B>E</B> 또는
<B>X</B> 명령어 다음에 나와야 합니다.
<B>uss</B> 명령이 실행되는 시스템의 로컬
디스크에서 파일을 작성하는 것은 <A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>에서
설명하는 여러 가지 이유로 인해 권장되지 않습니다.
<P>AFS에서는 동일한 디렉토리에 위치하는 파일간의 하드 연결만
허용한다는 사실을 알아 두십시오. 이러한 제한은 다른 ACL(두
디렉토리의 ACL)를 동일한 파일에 연관지음으로써 발생하는 혼란을
피하기 위해 필요합니다. 기호 연결은 다른 디렉토리, 심지어는
다른 볼륨에 위치하는 두 파일간에서 사용됩니다. 실제 파일에
대한 ACL도 연결에 적용됩니다.
<P>디렉토리나 파일에 대해 수행하는 것처럼 <B>L</B> 또는
<B>S</B> 명령어로 작성한 연결에 대해 소유자 또는 모드 비트를
설정할 필요가 없습니다. <B>uss</B> 명령 인터프리터는
<B>uss</B> 명령 실행자의 UNIX UID를 소유자로서 자동으로
기록하고 모드 비트를 <B>lrwxrwxrwx</B>(777)로 설정합니다.
<P><B>L</B> 또는 <B>S</B> 명령어의 필드에 대한
설명은 다음과 같이 <A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿에 나오는
예제를 참조합니다.
<PRE>   S /afs/example.com/public/$USER $MTPT/public
</PRE>
<P><B>L</B> 및 <B>S</B> 명령어의 구문은
다음과 같습니다.
<PRE>   L  <VAR>existing_file</VAR>  <VAR>link</VAR>
   S  <VAR>existing_file</VAR>  <VAR>link</VAR>
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>L</B>
</B><DD>하드 연결 작성 명령어를 나타냅니다.
<P><DT><B><B>S</B>
</B><DD>기호 연결 작성 명령어를 나타냅니다.
<P><DT><B><VAR>existing_file</VAR>
</B><DD>기존 파일의 완전한 경로 이름을 지정합니다. 이것이
사용자 홈 디렉토리나 그 하위 디렉토리에 있으면 $MTPT 변수를
사용하여 홈 디렉토리 경로 이름을 지정하는 것이 가장
간단합니다. $MTPT 변수는 <B>L</B> 또는
<B>S</B> 명령어에 나타나면 이전
<B>V</B> 명령의 <VAR>mount_point</VAR> 필드에서
그 값을 취합니다(이러한 종속성을 보면 <B>V</B>
명령어 다음에 나와야 하는 이유를 알 수 있습니다).
<P>
<P>이름이 숫자 기호(<B>#</B>)나 퍼센트
기호(<B>%</B>)로 시작하는 파일에 심볼릭 링크를
작성하지 마십시오. 캐쉬 관리 프로그램은 그 내용이 이들
문자 중 하나로 시작되는 기호 연결을 작성할 때 각각 일반
또는 읽기/쓰기 마운트 포인트로 해석합니다.
<P>
<P>Example Corporation 예제는 그 마운트 포인트로의 경로를 지정하여
선행하는 <B>X</B> 명령어에 의해 작성되어
마운트된 공개적으로 읽을 수 있는 볼륨으로의 연결을 작성합니다.
<P>
<PRE>   /afs/example.com/public/$USER
</PRE>
<P><DT><B><VAR>link</VAR>
</B><DD>파일에 대한 두 번째 이름의 완전한 경로 이름을 지정합니다.
이것이 사용자 홈 디렉토리나 그 하위 디렉토리에 있으면 $MTPT 변수를 사용하여
홈 디렉토리 경로 이름을 지정하는 것이 가장 간단합니다.
<P>
<P>연결로의 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 새 연결을
작성하려고 할 때 발생할 수 있는 장애를 피하십시오. 일반적으로, 경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을
찍어 읽기/쓰기 경로를 표시합니다(예를 들어, <B>/afs/.example.com</B>).
이 필드에 $MTPT 변수를 사용하는 경우 각 <B>V</B> 명령어의
<VAR>mount_point</VAR> 필드의 값은 이미 읽기/쓰기 경로를 나타내고 있을 것입니다. 파일 공간을 통한 읽기/쓰기와 읽기 전용
경로의 개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P>
<P>Example Corporation 예제는 사용자의 홈 디렉토리에 <B>public</B>이라는
연결을 작성합니다.
<P>
<PRE>   $MTPT/public
</PRE>
</DL>
<A NAME="IDX7695"></A>
<A NAME="IDX7696"></A>
<A NAME="IDX7697"></A>
<A NAME="IDX7698"></A>
<P><H3><A NAME="HDRWQ478" HREF="auagd002.htm#ToC_562">A 명령어로 계정 보안 높이기</A></H3>
<P>템플릿 파일의 <B>A</B> 명령어는 사용자 암호 선택 및
인증 시도에 대해 다음 제한을 부여하여 셀 보안을 강화합니다.
<UL>
<LI>사용자의 암호 수명 제한. 수명이 만기되면 사용자는 더 이상 해당 암호를
사용하여 인증을 받을 수 없으므로 암호를 변경해야 합니다.
</LI><LI>사용자의 가장 최근에 사용한 20가지 암호의 재사용 금지.
</LI><LI>사용자가 인증을 받는 동안 그리고 이 제한이 초과된 후에 인증 서버가 추가 인증
시도를 거부하는 기간 동안(<I>계정 잠금</I>으로 참조)
사용자가 잘못된 암호를 제공해도 문제가 되지 않는 연속 횟수 제한.
대부분의 셀에서 일반 사용자 계정 동안 권장되는 제한은 9번이고 잠금 시간은
25분입니다.
</LI></UL>
<P><B>A</B> 명령어의 필드에 대한 다음 설명은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿에 나오는 예제를 참조하며
암호 수명을 250일로 설정하고, 암호의 재사용을 금지하고, 실패한 인증 시도 수를
9로 제한하고, 인증 제한이 초과된 경우 25분의 잠금 시간을 생성합니다.
<PRE>   A $USER 250 noreuse 9 25
</PRE>
<P><B>A</B> 명령어의 구문은 다음과 같습니다.
<PRE>   A  <VAR>username</VAR>  <VAR>password_lifetime</VAR>  <VAR>password_reuse</VAR>  <VAR>failures</VAR>  <VAR>locktime</VAR>
</PRE>
<P>여기서,
<DL>
<P><DT><B><B>A</B>
</B><DD>보안 강화 명령어를 나타냅니다.
<P><DT><B><VAR>username</VAR>
</B><DD>보안 제한을 부여할 인증 데이터베이스 항목을 명명합니다.
$USER 변수를 사용하여 <B>uss add</B> 명령의
<B>-user</B> 인수로부터 또는 벌크 입력 파일의
<B>add</B> 명령어의 <VAR>username</VAR> 필드로부터
사용자 이름을 읽습니다. Example Corporation 예제는 이 값을 사용합니다.
<P><DT><B><VAR>password_lifetime</VAR>
</B><DD>사용자 암호가 변경된 후에 암호가 유효한 상태로 남아 있는 일 수를
설정합니다. 암호가 유효하지 않게 되면(만기) 사용자는 인증을 받을 수 없게
되지만 30일 내에 <B>kpasswd</B> 명령을 실행하여
암호를 변경할 수 있습니다(그 이후에는 관리자가 이를 변경해야 함).
<P>
<P>범위 <B>1</B> - <B>254</B>의 정수를 지정하여
만기가 될 때까지의 일 수를 지정하는 데 여기서 값 <B>0</B>은
암호가 절대 만기되지 않음을 나타내고 값 $PWEXPIRES는
<B>uss add</B> 또는 <B>uss bulk</B> 명령의
<B>-pwexpires</B> 인수로부터 일 수를 읽어오게 됩니다.
<B>A</B> 명령어가 템플릿 파일에 나타나지 않으면 기본적으로
사용자 암호는 만기되지 않습니다.
<P>
<P>Example Corporation 예제는 250일의 암호 수명을 설정합니다.
<P><DT><B><VAR>password_reuse</VAR>
</B><DD>사용자가 마지막 20개의 암호 중 하나와 유사한 암호로
암호를 변경할 수 있는지 여부를 결정합니다(<B>kpasswd</B>
또는 <B>kas setpassword</B> 명령 사용). 허용되는
값은 재사용을 허용하는 <B>reuse</B>와 재사용을
금지하는 <B>noreuse</B>입니다. <B>A</B>
명령어가 템플릿 파일에 나타나지 않으면 기본값은 암호 재사용을
허용하는 것입니다.
<P>
<P>Example Corporation 예제는 암호 재사용을 금지합니다.
<P><DT><B><VAR>failures</VAR>
</B><DD>사용자가 인증 동안 잘못된 암호를 제공해도 문제가 되지
않는 연속 횟수를 설정합니다(<B>klog</B> 명령이나
AFS 토큰을 부여하는 로그인 유틸리티 사용). 사용자가 제한을
초과하면 인증 서버는 <VAR>locktime</VAR> 필드에 지정된 시간 동안
추가적인 인증 시도를 거부합니다.
<P>
<P>범위 <B>1</B> - <B>254</B>의
정수를 지정하여 허용되는 실패 횟수를 지정하거나 실패한 시도 수를
제한하지 않도록 하는 <B>0</B> 값을 지정하십시오.
<B>A</B> 명령어가 템플릿 파일에 나타나지 않으면
기본값은 제한 없는 실패를 허용하는 것입니다.
<P>
<P>Example Corporation 예제는 실패한 시도 횟수를 9회로 제한합니다.
<P><DT><B><VAR>locktime</VAR>
</B><DD>인증 서버가 <VAR>failures</VAR> 필드에 설정된 실패 제한을 초과한
사용자로부터의 인증 시도를 거부하는 기간을 지정합니다.
<P>
<P>범위 <B>01</B>(1분) - <B>36:00</B>(36시간)에서
시간과 분(<VAR>hh</VAR>:<VAR>mm</VAR>) 또는 분(<VAR>mm</VAR>)만을
지정하십시오. 인증 서버는 더 큰 값은 <B>36:00</B>으로 자동으로
줄이고 8.5분의 배수 중 해당 시간에서 가장 가까운 값으로 0이 아닌 값을
올림합니다. 값 <B>0</B>은 무한 잠금 시간을 설정하며 이 경우
관리자는 <B>kas unlock</B> 명령을 실행하여 계정을 잠금
해제해야 합니다.
<P>
<P>Example Corporation 예제는 잠금 시간을 25분으로 설정하고 이 시간은 25분
30초(8.5분의 배수 중 25분에서 가장 가까운 시간)로 올림됩니다.
</DL>
<A NAME="IDX7699"></A>
<A NAME="IDX7700"></A>
<A NAME="IDX7701"></A>
<A NAME="IDX7702"></A>
<A NAME="IDX7703"></A>
<A NAME="IDX7704"></A>
<P><H3><A NAME="HDRWQ479" HREF="auagd002.htm#ToC_563">X 명령어를 사용하여 명령 실행</A></H3>
<P>템플릿 파일의 <B>X</B> 명령어는 표준 UNIX 명령, 쉘 스크립트나
프로그램 또는 AFS 명령을 실행합니다. 명령 문자열에는 표준 템플릿 변수가
포함될 수 있으며 템플릿 파일에 나타날 수 있는 <B>X</B> 명령어의
수에는 제한이 없습니다. 명령어가 다른 명령어에 의해 작성된 요소를 처리하는
경우 해당 명령어 다음에 나타나야 합니다.
<P><B>X</B> 명령어의 필드에 대한 다음 설명은
<A HREF="#HDRWQ471">예제 uss 템플릿</A>의 전체 계정 템플릿에 나오는 예제를 참조합니다.
<PRE>   X "create_public_vol $USER $1 $2"
</PRE>
<P><B>X</B> 명령어의 구문은 다음과 같습니다.
<PRE>   X "<VAR>command</VAR>"
</PRE>
<P>여기서 <VAR>command</VAR>는 실행할 명령을 지정합니다. 공백이 포함된 경우에는
큰 따옴표(")로 묶으십시오. 명령 문자열에는 어떠한 표준 변수도 포함될 수
있으며 <B>uss</B> 명령은 적절한 다른 명령 인터프리터에 이
명령을 제공하기 전에 이 변수를 해석하지만 개행 문자를 포함할 수 없습니다.
<P>Example Corporation 예제는 <B>create_public_vol</B>이라는
스크립트를 호출합니다. 이 스크립트는 새 사용자와 연관된 다른 볼륨을
작성하고 이 볼륨을 Example Corporation의 파일 공간에서 공개적으로 읽을 수 있는
부분에 마운트합니다.
<PRE>   "create_public_vol $USER $1 $2"
</PRE>
<P>이 예제는 $USER 변수를 사용하여 사용자 이름을 읽고 이를 볼륨 이름과
마운트 포인트 이름 둘다의 일부로 만듭니다. <B>uss</B> 명령은
$1 변수에 대해서는 파일 서버 시스템 이름을 제공하고 $2 변수에 대해서는
파티션 이름을 제공하여 새 볼륨에 대한 사이트를 지정합니다.
<A NAME="IDX7705"></A>
<A NAME="IDX7706"></A>
<A NAME="IDX7707"></A>
<A NAME="IDX7708"></A>
<A NAME="IDX7709"></A>
<A NAME="IDX7710"></A>
<A NAME="IDX7711"></A>
<A NAME="IDX7712"></A>
<A NAME="IDX7713"></A>
<A NAME="IDX7714"></A>
<A NAME="IDX7715"></A>
<HR><H2><A NAME="HDRWQ480" HREF="auagd002.htm#ToC_564">uss add 명령을 사용한 개별 계정 작성</A></H2>
<P>템플릿 파일을 작성한 후에 <B>uss add</B>
명령(템플릿 작성에 대해서는 <A HREF="#HDRWQ463">uss 템플릿 파일 구성</A> 참고)을 실행하여
개별 계정을 작성할 수 있습니다. 이 명령을 실행할 때 <B>uss</B>
명령 인터프리터는 다양한 AFS 서버에 접속하여 다음 작업을 수행합니다.
<UL>
<LI>보호 데이터베이스 항목을 작성합니다. 기본적으로 보호 서버는 템플릿에서
사용되는 $UID 변수의 값이 되는 AFS UID를 지정합니다.
</LI><LI>인증 데이터베이스 항목을 작성하고 초기 암호의 암호화 버전을 기록합니다.
</LI><LI>지정된 템플릿 파일에 정의된 계정 구성요소를 작성하고, 필요에 따라
파일 서버, 볼륨 서버 및 볼륨 위치(VL) 서버에 접속합니다.
</LI></UL>
<P>다른 파일 시스템 오브젝트를 작성하기 위해 템플릿에 포함시켜야 하는 명령어
유형을 검토하려면 <A HREF="#HDRWQ463">uss 템플릿 파일 구성</A>을 참조하십시오. 템플릿이
비어 있으면 <B>uss add</B> 명령은 보호 데이터베이스 및
인증 데이터베이스 항목으로 구성된 인증 전용 계정을 작성합니다.
<P><B>uss add</B> 명령을 실행할 때는 해당 명령 인수를 포함시켜
템플릿 파일의 각 변수에 대해 값을 제공하십시오. 변수 값을 제공하지 못하면
<B>uss</B> 명령 인터프리터는 계정 작성의 실패를 유발하는
널 문자열을 대체합니다. 해당 변수가 템플릿에 나타나지 않는 명령행 인수를
포함시키는 경우 이 인수는 무시됩니다.
<P><A HREF="#TBLWQ481">표 4</A>에서는 <B>uss add</B>
명령과 변수 및 인수간의 맵핑을 요약해서 보여줍니다. 이 테이블은
<A HREF="#TBLWQ466">표 3</A>에서 발췌한 것이지만 그 값을 명령행
인수에서 취하는 변수만 포함되어 있습니다.
<BR>
<P><B><A NAME="TBLWQ481" HREF="auagd004.htm#FT_TBLWQ481">표 4. uss 템플릿 변수에 대한 명령행 인수 원본</A></B><BR>
<TABLE WIDTH="100%" BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>변수</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>명령행 인수</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$MTPT
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-mount</B> (<B>V</B> 명령어에서 사용)
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$NAME
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">제공되는 경우 <B>-realname</B>, 그렇지 않은 경우
<B>-user</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$PART
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-partition</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$PWEXPIRES
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-pwexpires</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$SERVER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-server</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$UID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">제공되는 경우 <B>-uid</B>, 그렇지 않은 경우
보호 서버에 의해 할당
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$USER
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-user</B>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">$1에서 $9
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%"><B>-var</B>
</TD></TR></TABLE>
<P><H3><A NAME="HDRWQ483" HREF="auagd002.htm#ToC_565">uss add 명령을 사용하여 AFS 계정을 작성하려면</A></H3>
<OL TYPE=1>
<LI>다음 특권을 전부 사용하여 AFS ID를 인증하십시오. 전형적인
구성에서 <B>admin</B> 사용자 계정에는 이것이
들어 있거나 사용자에게 개인 관리 계정이 있을 수 있습니다(셀
보안을 증가하려면 관리 프로시듀어를 수행하는 중에만 사용할
수 있도록 특별 권한 계정을 작성하는 것이 가장 좋습니다. 더
자세한 내용은 <A HREF="auagd021.htm#HDRWQ584">관리 특권 개요</A>를 참조하십시오).
필요한 경우 <B>klog</B> 명령을 실행하여 인증하십시오.
<P>
<PRE>   % <B>klog</B> <VAR>admin_user</VAR>
   Password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>다음 목록은 필요한 특권을 지정하고 이를 가지고 있는지 확인하는 방법을 나타냅니다.
<UL>
<LI><B>system:administrators</B> 그룹에서의
멤버쉽.
필요하면 <A HREF="auagd021.htm#HDRWQ587">system:administrators 그룹 구성원을 표시하려면</A>에서 자세히 설명되어 있는
<B>pts membership</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>pts membership system:administrators</B>

</PRE>
</LI><LI><B>/usr/afs/etc/UserList</B> 파일에
포함.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>인증 데이터베이스 항목의 <TT>ADMIN</TT> 플래그. 그러나
인증 서버는 자체의 인증을 수행하기 위해 항상 사용자에게 암호를
묻습니다. 다음 명령어는 <B>uss</B> 명령행 자체에
관리 ID를 지정하도록 지시합니다.
</LI><LI>사용자 볼륨을 마운트하고 있는 디렉토리의 ACL에
대한 <B>i</B>(<B>삽입</B>) 및
<B>l</B>(<B>조회</B>) 권한.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI></UL>
</LI><LI><B>(선택적)</B> 로컬 수퍼유저
<B>루트</B>로서 로그인하십시오. 이것은 로컬
파일 시스템에 새 파일이나 디렉토리를 작성하며 오브젝트가
작성될 때 대체 소유자를 지정하려는 경우에만 필요합니다. 관련
문제점에 대한 설명을 보려면 <A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>를
참조하십시오.
</LI><LI>사용중인 템플릿 파일의 위치와 기능을 확인하십시오.
<B>uss</B> 명령 인터프리터가 해당 템플릿을
어디에서 찾을지에 대한 설명을 보려면
<A HREF="#HDRWQ468">템플릿 파일을 저장할 위치</A>를 참조하십시오. 원하는 경우
항상 대체 경로 이름을 제공할 수 있습니다. 또한 템플릿에서
사용되는 변수를 확인하여 <B>uss</B> 명령행에
올바른 인수를 제공했는지 확인하십시오.
</LI><LI><A NAME="LIWQ484"></A><B>(선택적)</B> 템플릿이 있는
디렉토리로 변경하십시오. 이것은 단계 <A HREF="#LIWQ485">6</A>에서
입력해야 하는 경로 이름의 유형을 반영합니다.
<P>
<PRE>   % <B>cd</B> <VAR>template_directory</VAR>
</PRE>
</LI><LI><B>(선택적)</B> <B>-dryrun</B> 플래그와
함께 <B>uss add</B> 명령을 실행하여 계정 작성을 미리
검토하십시오. <B>-dryrun</B> 플래그를 사용하지 않고 명령을
다시 실행하기 전에 오류 메시지를 살펴 보고 원인을 수정하십시오. 다음 단계에서는
<B>uss add</B> 명령의 구문을 설명합니다. <B>-dryrun</B>
플래그에 대한 자세한 정보를 보려면 <A HREF="#HDRWQ454">오류 및 인터럽트된 조작 피하기 및 복구</A>를 참조하십시오.
<A NAME="IDX7716"></A>
<A NAME="IDX7717"></A>
</LI><LI><A NAME="LIWQ485"></A><B>uss add</B> 명령을 실행하여 계정을
작성하십시오. 단일 행에 명령을 입력하십시오. 여기에서는 이해하기 편리하도록
여러 행으로 나타낸 것입니다.
<P>
<P><B>uss add</B> 조작은 인증 데이터베이스 항목을 작성합니다.
인증 서버는 기존 AFS 토큰을 사용하지 않고 자신의 인증 프로세스를
수행합니다. 기본적으로 이것은 로컬(UNIX) ID를 인증하며, AFS가 특권을
부여한 관리자에 해당되지 않을 수 있습니다.
<B>-admin</B> 인수를 삽입하여 인증 데이터베이스
항목에 <TT>ADMIN</TT> 플래그가 있는 ID의 이름을 지정하십시오.
항목에 플래그가 있는 지 확인하려면, <A HREF="auagd021.htm#HDRWQ590">ADMIN 플래그가 설정되어 있는지 확인하려면</A>에서
설명한 것처럼 <B>kas examine</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>uss add</B> <B>-user</B> &lt;<VAR>login&nbsp;name</VAR>>
<B>-admin</B> &lt;<VAR>administrator&nbsp;to&nbsp;authenticate</VAR>>   \
             [<B>-realname</B> &lt;<VAR>full&nbsp;name&nbsp;in&nbsp;quotes</VAR>>] [<B>-pass</B> &lt;<VAR>initial&nbsp;passwd</VAR>>]   \
             [<B>-pwexpires</B> &lt;<VAR>password&nbsp;expires&nbsp;in&nbsp;[0..254]&nbsp;days&nbsp;(0&nbsp;=>&nbsp;never)</VAR>>]  \
             [<B>-server</B> &lt;<VAR>FileServer&nbsp;for&nbsp;home&nbsp;volume</VAR>>]  \
             [<B>-partition</B> &lt;<VAR>FileServer's&nbsp;disk&nbsp;partition&nbsp;for&nbsp;home&nbsp;volume</VAR>>]  \
             [<B>-mount</B> &lt;<VAR>home&nbsp;directory&nbsp;mount&nbsp;point</VAR>>]  \
             [<B>-uid</B> &lt;<VAR>uid&nbsp;to&nbsp;assign&nbsp;the&nbsp;user</VAR>>]  \
             [<B>-template</B> &lt;<VAR>pathname&nbsp;of&nbsp;template&nbsp;file</VAR>>]  \
             [<B>-var</B> &lt;<VAR>auxiliary&nbsp;argument&nbsp;pairs&nbsp;(Numval)</VAR>><SUP>+</SUP>] [<B>-dryrun</B>] \
             [<B>-overwrite</B>]
    Administrator's (<VAR>admin_user</VAR>) password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>여기서,
<P>
<DL>
<P><DT><B>ad
</B><DD>허용되는 <B>add</B>의 가장 짧은 축약형입니다.
<P><DT><B>-user
</B><DD>사용자의 인증 데이터베이스 및 보호 데이터베이스 항목을
명명합니다. 이것이 사용자 이름이 되므로(사용자가 로그인할 때
사용하는 이름), 여러 운영 체제에서 사용자 이름에 대해 부여하는
제한을 준수해야 합니다(보통 8자까지만 포함). 다음과 같은
문자를 피하십시오. 콜론(<B>:</B>),
세미콜론(<B>;</B>),
쉼표(<B>,</B>), at 기호(<B>@</B>),
공백, 새 행 그리고 마침표(<B>.</B>)입니다.
이런 문자는 특별 관리 이름에만 주로 사용됩니다.
<P>
<P>이 인수는 템플릿 파일의 $USER 변수에 대한 값을 제공합니다.
사용자 이름 표준화에 대한 제안을 보려면
<A HREF="auagd007.htm#HDRWQ58">사용자 이름 선택 및 다른 계정 구성요소 명명</A>을 참조하십시오.
<P><DT><B>-admin
</B><DD><TT>admin</TT> 플래그와 같은 그 인증 데이터베이스
항목에 <B>ADMIN</B> 플래그가 있는 관리 계정을
명명합니다. 암호 프롬프트는 이를 <VAR>admin_user</VAR>로
표시합니다. 적합한 암호를 <VAR>admin_password</VAR>로 입력합니다.
<P><DT><B>-realname
</B><DD>사용자의 실제 이름을 지정합니다. 공백이나 마침표가 포함된 경우
큰 따옴표(")로 묶으십시오. 이 이름을 제공하지 않으면 기본적으로
<B>-user</B> 인수와 함께 제공되는 사용자 이름이 됩니다.
<P>
<P>이 인수는 템플릿 파일의 $NAME 변수에 대한 값을 제공합니다.
이 인수와 변수를 <B>/etc/passwd</B>와 같은
로컬 암호 파일에 항목을 작성하기 위한 자동 프로세스의 일부로
사용하는 것에 대한 정보를 보려면 <A HREF="#HDRWQ458">공통 원본 암호 파일 작성</A>을
참조하십시오.
<P><DT><B>-pass
</B><DD>사용자의 초기 암호를 지정합니다. 암호를 처리하는 AFS
명령들이 가상으로는 전혀 제한이 없는 길이의 문자열을
허용한다고 해도 많은 응용프로그램과 유틸리티에서 허용하는
최대 길이인 8자 이하의 암호를 사용하는 것이 좋습니다.
<P>
<P>초기 암호로 선택할 수 있는 것 중에는 사용자 이름, 사회
보장 번호와 같은 개인 ID 번호 또는
<B>changeme</B>와 같은 표준 문자열이
있습니다. 템플릿 파일에서는 해당 변수에 대한 제한이 없습니다.
<P>
<P>사용자에게 처음으로 AFS에 대해 인증을 받자마자 비밀 문자열로
암호를 변경하도록 지시하십시오. <I>AFS 사용자 안내서</I>에서는
<B>kpasswd</B> 명령을 사용하여
AFS 암호를 변경하는 방법을 설명합니다.
<P><DT><B>-pwexpires
</B><DD>사용자 암호가 변경된 후에 유효한 상태로 남아 있는
일 수를 설정합니다. 범위 <B>1</B> -
<B>254</B>의 정수를 지정하여 만기가
될 때까지의 일 수를 지정하거나 값 <B>0</B>을
지정하여 암호가 절대 만기되지 않도록 지정하십시오(이 인수를
제공하지 않는 경우 0이 기본값임). 암호가 유효하지 않게
되면(만기) 사용자는 인증을 받을 수 없게 되지만 30일 내에
<B>kpasswd</B> 명령을 실행하여 암호를 변경할
수 있습니다. 그 이후에는 관리자만 암호를 변경할 수 있습니다.
<P>
<P>이 인수는 템플릿 파일의 $PWEXPIRES 변수에 대한 값을 제공합니다.
<P><DT><B>-server
</B><DD>새 사용자의 홈 볼륨을 작성할 파일 서버 시스템을 명명합니다.
완전 규정화된 호스트 이름(예: <B>fs1.example.com</B>)을
제공하는 것이 가장 바람직하지만 셀의 명명 서비스를 사용하여
<B>uss add</B> 명령을 실행할 때 약어 형태를
해석할 수 있으면 약어 형태도 허용됩니다.
<P>
<P>이 인수는 템플릿 파일의 $SERVER 변수에 대한 값을 제공합니다.
명령행에 완전 규정화된 호스트 이름을 입력하지 않아도 되게 하려면
템플릿 파일에서 <B>V</B> 명령어의 <VAR>server</VAR> 필드에서
상수(예: 셀의 도메인 이름)를 $SERVER 변수와 조합해서 사용하십시오.
예를 들면 <A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>을 참조하십시오.
<P><DT><B>-partition
</B><DD>사용자 홈 볼륨을 작성할 파티션을 지정합니다. 이 파티션은
<B>-server</B> 인수에서 명명한 파일 서버 시스템에 있어야 합니다.
그 완전한 이름(예: <B>/vicepa</B>)으로 파티션을 식별하거나
<A HREF="auagd023.htm#HDRWQ615">약어 및 별명 사용 규칙</A>에 나열된 약어 중 하나를 사용하십시오.
<P>
<P>이 인수는 템플릿 파일의 $PART 변수에 대한 값을 제공합니다.
<P><DT><B>-mount
</B><DD>셀의 읽기/쓰기 파일 공간에 있는 사용자의 홈 디렉토리에
대한 경로 이름을 지정합니다. 부분적 경로 이름은 현재 작업
디렉토리와의 관계에 따라 해석됩니다.
<P>
<P>이 인수는 템플릿 파일의 $MTPT 변수에 대한 값을 제공하지만
<B>V</B> 명령어의 <VAR>mount_point</VAR> 필드에
나타날 때만 해당됩니다. $MTPT 변수는 후속 명령어에 나타나면
이 인수로부터 직업이 아니라 <B>V</B> 명령어의
<VAR>mount_point</VAR> 필드에서 그 값을 취합니다. 세부사항과
이 인수 및 $MTPT 변수를 사용하는 방법에 대한 제안을 보려면
<A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>을 참조하십시오.
<P><DT><B>-uid
</B><DD>사용자의 AFS UID로 지정할 <B>0</B>이
아닌 양의 정수를 지정합니다. 이 인수를 생략하고 보호 서버가
현재 <TT>max user id</TT> 카운트 값보다 더 큰 AFS UID를
지정하게 하는 것이 좋습니다(카운트를 표시하려면
<A HREF="auagd019.htm#HDRWQ561">AFS ID 카운터를 표시하려면</A>에서 설명하는 것처럼
<B>pts listmax</B> 명령을 사용하십시오).
<P>
<P>이 인수를 사용해야 하는 경우에는(사용자가 이미 UNIX UID를
가지는 경우) 먼저 <B>pts examine</B> 명령을
사용하여 원하는 AFS UID를 가진 기존의 계정이 없는지
확인하십시오. 기존 계정이 있으면 계정 작성 프로세스를
오류를 나타내며 종료됩니다.
<P>
<P>이 인수는 템플릿 파일의 $UID 변수에 대한 값을 제공합니다.
<P><DT><B>-template
</B><DD>템플릿 파일의 경로 이름을 지정합니다. 이 인수를 생략하면
명령 인터프리터는 각 디렉토리에서 차례대로
<B>uss.template</B>라는 템플릿 파일을 탐색합니다.
<P>
<OL TYPE=a>
<LI>현재 작업 디렉토리
</LI><LI><B>/afs/</B><VAR>cellname</VAR><B>/common/uss</B>, 여기서 <VAR>cellname</VAR>은 로컬 셀을 명명합니다.
</LI><LI><B>/etc</B>
</LI></OL>
<P>
<P>
<P>경로 이름을 가지지 않는 <B>uss.template</B> 이외의 파일 이름을
지정하는 경우 명령 인터프리터는 지정된 디렉토리에서 이를 탐색합니다.
전체 경로 이름이나 부분 경로 이름을 제공하면 명령 인터프린터는 지정된 파일만
확인합니다. 현재 작업 디렉토리에 상대적으로 부분 경로 이름을 해석합니다.
<P>
<P>지정된 템플릿 파일이 비어 있으면(0길이), 명령은 보호 및
인증 데이터베이스 항목만 작성합니다.
<P>
<P>템플릿 파일을 구성하는 방법을 알려면
<A HREF="#HDRWQ463">uss 템플릿 파일 구성</A>을 참조하십시오.
<P><DT><B>-var
</B><DD>템플릿 파일에 나타날 수 있는 $1 - $9 범위의 숫자 변수 각각에 대한
값을 지정합니다. 이 숫자 변수를 사용하여 표준 집합의 일부가 아닌 변수에
대한 값을 <B>uss</B> 템플릿 파일에 지정할 수 있습니다.
<P>
<P>이 인수의 각 인스턴스에 대해 지정된 순서로 두 부분을 공백으로 구분하여
제공하십시오.
<UL>
<LI>템플릿 파일의 변수에 해당하는 범위 <B>1</B> -
<B>9</B>의 정수. 앞에 달러 기호를 사용하지 마십시오.
</LI><LI>변수의 값으로 지정할 영숫자 문자열.
</LI></UL>
<P>
<P>
<P>숫자 변수의 제안된 사용 방식에 대한 설명을 보려면 <A HREF="#HDRWQ473">V 명령어를 사용한 볼륨 작성</A>에서
<B>V</B> 명령어의 <VAR>quota</VAR> 필드에 대한 설명을
참조하십시오.
<P><DT><B>-dryrun
</B><DD>명령 인터프리터가 실제로 명령을 수행하지는 않으면서 명령을 수행하기
위해 필요로 하는 조치를 기록합니다.
<P><DT><B>-overwrite
</B><DD>파일 시스템에 존재하고 <B>-template</B> 인수에 의해
명명된 템플릿 파일의 <B>D</B>,
<B>E</B>, <B>F</B>, <B>L</B>
또는 <B>S</B> 명령어에 그 정의가 있는 디렉토리, 파일 및
연결을 덮어씁니다.
이 플래그를 생략하면 명령 인터프리터는 이러한 모든 요소를 덮어쓸지 확인하는
메시지를 한 번 표시합니다.
</DL>
</LI><LI>새 사용자 홈 디렉토리가 복제된 볼륨에 상주하면
<B>vos release</B> 명령을 사용하여 <A HREF="auagd010.htm#HDRWQ194">읽기/쓰기 볼륨을 복제하려면 (읽기 전용 볼륨 작성)</A>의
설명 대로 볼륨을 해제하십시오.
<P>
<PRE>
   % <B>vos release</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>

</PRE>
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 단계는 홈 디렉토리의 상위 디렉토리 그 자체가 복제된 볼륨의 마운트 포인트가 아니어도
필요합니다(그리고 이런 경우 더 쉽게 지나침). 예를 들어 Example Corporation
템플릿은 <B>/afs/example.com/usr</B> 디렉토리에 사용자 볼륨에 대한
마운트 포인트를 추가합니다. 이는
마운트 포인트이기 보다 일반 디렉토리이므로 <B>/afs/example.com</B> 디렉토리에
마운트된 <B>root.cell</B> 볼륨에 상주합니다. 그 볼륨은 복제되므로
새 마운트 포인트를 작성하여 이를 변경한 후 관리자는 <B>vos release</B> 명령을
실행해야 합니다.
</TD></TR></TABLE>
</LI><LI>사용자가 로그온할 수 있는 각 AFS 클라이언트 시스템의 로컬 암호
파일(<B>/etc/passwd</B> 또는 동급)에 새 사용자에 대한
항목을 작성하십시오. 이 단계를 자동화하는 방법에 대해서는
<A HREF="#HDRWQ458">공통 원본 암호 파일 작성</A>을 참조하십시오.
<P>
<P>자동화 방법을 사용하지 않는 경우에도 사용자의 UNIX UID가 보호 서버에서
자동으로 지정했거나 <B>-uid</B> 인수를 사용하여 지정한
AFS UID에 일치하도록 설정하십시오. 새로운 사용자의 AFS UID가
<B>uss add</B> 출력에서 생성한 추적에 나타납니다. 그렇지
않은 경우에는 <A HREF="auagd019.htm#HDRWQ537">보호 데이터베이스 항목을 표시하려면</A>에서 설명하는 것처럼
<B>pts examine</B> 명령을 사용하여 표시할 수 있습니다.
</LI></OL>
<A NAME="IDX7718"></A>
<A NAME="IDX7719"></A>
<A NAME="IDX7720"></A>
<A NAME="IDX7721"></A>
<A NAME="IDX7722"></A>
<A NAME="IDX7723"></A>
<A NAME="IDX7724"></A>
<HR><H2><A NAME="HDRWQ486" HREF="auagd002.htm#ToC_566">uss delete 명령을 사용한 개별 계정 삭제</A></H2>
<P><B>uss delete</B> 명령은 사용자가 명령행에 제공하는 인수에
따라 AFS 사용자 계정을 삭제합니다. 이 명령은 <B>uss add</B>
명령과는 달리 템플릿 파일을 사용하지 않습니다. 이 명령을 실행할 때 <B>uss</B>
명령 인터프리터는 다양한 AFS 서버에 접속하여 다음 작업을 수행합니다.
<UL>
<LI>사용자의 홈 볼륨에 대한 마운트 포인트를 제거
</LI><LI><B>-savevolume</B> 플래그를 포함시키지 않는 경우에도
사용자의 홈 볼륨을 제거하고 연관된 VLDB 항목을 삭제
</LI><LI>사용자의 인증 데이터베이스 항목 삭제
</LI><LI>사용자의 보호 데이터베이스 항목 삭제
</LI></UL>
<P><B>uss delete</B> 명령을 실행하기 전에 다음의 선택적 타스크를
수행할 수 있습니다.
<UL>
<LI>사용자의 홈 볼륨을 테이프나 다른 영구 매체에 복사하고
사용자 이름과 UID를 예약 목록에 기록하십시오. 이 정보를
사용하면 사용자가 셀로 되돌아가는 경우 쉽게 사용자의 계정을
복원할 수 있습니다. AFS 백업 시스템을 사용하여 볼륨을
백업하는 것에 대한 정보를 보려면 <A HREF="auagd011.htm#HDRWQ248">AFS 백업 시스템 구성</A>
및 <A HREF="auagd012.htm#HDRWQ283">AFS 데이터 백업 및 복원</A>을 참조하십시오.
</LI><LI>사용자가 다른 볼륨을 독점적으로 사용하는 경우(프로젝트
관련 데이터를 저장하기 위한 볼륨), 각 볼륨의 백업 사본을
작성한 다음 <A HREF="auagd010.htm#HDRWQ235">볼륨 및 마운트 포인트 제거</A>에서 지정하는 것처럼
해당 볼륨과 마운트 포인트를 제거하십시오.
</LI><LI><B>pts listowned</B> 명령을 사용하여
사용자가 소유하는 그룹을 표시하십시오.
<A HREF="auagd019.htm#HDRWQ540">사용자나 그룹이 소유한 그룹 나열</A>에서 지침을 참조하십시오.
<B>pts delete</B> 명령을 실행하여 그룹을
제거할지 아니면 <B>pts chown</B> 명령을
실행하여 소유권을 다른 사용자나 그룹에게 전환할지 여부를
결정하십시오. <A HREF="auagd019.htm#HDRWQ553">보호 데이터베이스 항목을 삭제하려면</A> 및
<A HREF="auagd019.htm#HDRWQ555">그룹 소유자를 변경하려면</A>에서 지침을 참조하십시오. 또는
사용자가 빠져 나가기 전에 그룹의 소유권을 제거하거나
전환하게 할 수 있습니다. 그 소유자가 제거된 후에 보호
데이터베이스에 남아 있는 그룹은 <VAR>고립된</VAR> 항목으로
고려되며 <B>system:administrators</B> 그룹의
구성원만 이 항목을 관리할 수 있습니다.
</LI></UL>
<P>벌크 입력 파일에 <B>exec</B> 명령어를
포함시키고 <B>uss bulk</B> 명령을 사용하여
계정을 삭제함으로써 이들 타스크를 자동화할 수 있습니다.
<A HREF="#HDRWQ488">uss bulk 명령을 사용하여 복수의 계정 작성 및 삭제</A>를 참조하십시오.
<P><H3><A NAME="HDRWQ487" HREF="auagd002.htm#ToC_567">AFS 계정을 삭제하려면</A></H3>
<OL TYPE=1>
<LI>다음 특권을 전부 사용하여 AFS ID를 인증하십시오. 전형적인
구성에서 <B>admin</B> 사용자 계정에는 이것이
들어 있거나 사용자에게 개인 관리 계정이 있을 수 있습니다(셀
보안을 증가하려면 관리 프로시듀어를 수행하는 중에만 사용할
수 있도록 특별 권한 계정을 작성하는 것이 가장 좋습니다. 더
자세한 내용은 <A HREF="auagd021.htm#HDRWQ584">관리 특권 개요</A>를 참조하십시오).
필요한 경우 <B>klog</B> 명령을 실행하여
인증하십시오.
<P>
<PRE>   % <B>klog</B> <VAR>admin_user</VAR>
   Password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>다음 목록은 필요한 특권을 지정하고 이를 가지고 있는지 확인하는 방법을 나타냅니다.
<UL>
<LI><B>system:administrators</B> 그룹에서의 멤버쉽.
필요하면 <A HREF="auagd021.htm#HDRWQ587">system:administrators 그룹 구성원을 표시하려면</A>에서 자세히 설명되어 있는
<B>pts membership</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>pts membership system:administrators</B>

</PRE>
</LI><LI><B>/usr/afs/etc/UserList</B> 파일에 포함.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>인증 데이터베이스 항목의 <TT>ADMIN</TT> 플래그. 그러나 인증 서버는
자체의 인증을 수행하기 위해 항상 사용자에게 암호를 묻습니다. 다음 명령어는
<B>uss</B> 명령행 자체에 관리 ID를 지정하도록 지시합니다.
</LI><LI>사용자의 홈 디렉토리가 있는 디렉토리의 ACL에 대한
<B>d</B>(<B>삭제</B>) 권한.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI></UL>
</LI><LI>삭제된 사용자 계정 정보, 소유된 그룹 및 볼륨의 계속적인 유지와 관련되어
이 절의 개요 부분에서 설명하는 문제점을 고려하고 해결하십시오.
</LI><LI><B>(선택적)</B> <B>-dryrun</B> 플래그와
함께 <B>uss delete</B> 명령을 실행하여 계정 삭제를 미리
검토하십시오. <B>-dryrun</B> 플래그를 사용하지 않고 명령을
다시 실행하기 전에 오류 메시지를 살펴 보고 원인을 수정하십시오. 다음 단계에서는
<B>uss delete</B> 명령의 구문을 설명합니다.
<A NAME="IDX7725"></A>
<A NAME="IDX7726"></A>
</LI><LI><B>uss delete</B> 명령을 실행하여 계정을 삭제하십시오.
단일 행에 명령을 입력하십시오. 여기에서는 이해하기 편리하도록
여러 행으로 나타낸 것입니다.
<P>
<P>삭제 조작을 수행하면 항상 인증 데이터베이스에서 사용자 항목이 제거됩니다.
인증 서버는 기존 AFS 토큰을 사용하지 않고 자신의 인증 프로세스를
수행합니다. 기본적으로 이것은 로컬(UNIX) ID를 인증하며, AFS가 특권을
부여한 관리자에 해당되지 않을 수 있습니다.
<B>-admin</B> 인수를 삽입하여 인증 데이터베이스
항목에 <TT>ADMIN</TT> 플래그가 있는 ID의 이름을 지정하십시오.
항목에 플래그가 있는 지 확인하려면, <A HREF="auagd021.htm#HDRWQ590">ADMIN 플래그가 설정되어 있는지 확인하려면</A>에서
설명한 것처럼 <B>kas examine</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>uss delete</B> <B>-user</B> &lt;<VAR>login&nbsp;name</VAR>>  \
                <B>-mountpoint</B> &lt;<VAR>mountpoint&nbsp;for&nbsp;user's&nbsp;volume</VAR>>  \
                [<B>-savevolume</B>]  <B>-admin </B> &lt;<VAR>administrator&nbsp;to&nbsp;authenticate</VAR>>  \
                [<B>-dryrun</B>]
    Administrator's (<VAR>admin_user</VAR>) password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>여기서,
<P>
<DL>
<P><DT><B>d
</B><DD>사용할 수 있는 <B>delete</B>의 가장 짧은 축약형입니다.
<P><DT><B>-user
</B><DD>보호 및 인증 데이터베이스에서 삭제할 항목을 명명합니다.
<P><DT><B>-mountpoint
</B><DD>삭제할 마운트 포인트(사용자의 홈 디렉토리)의 경로 이름을 지정합니다.
<B>-savevolume</B> 인수를 포함하지 않는 한 이 지점에 마운트된
볼륨도 VLDB에서 레코드가 삭제되는 것처럼 파일 서버 시스템에서 삭제됩니다.
부분적 경로 이름은 현재 작업 디렉토리와의
관계에 따라 해석됩니다.
<P>
<P>마운트 포인트로의 읽기/쓰기 경로를 지정하여 읽기 전용 볼륨에서 마운트 포인트를
삭제하려고 할 때 발생할 수 있는 장애를 피하십시오. 일반적으로, 경로 이름의 두 번째 레벨에서 셀 이름 앞에 점을
찍어 읽기/쓰기 경로를 표시합니다(예를 들어, <B>/afs/.example.com</B>). 파일 공간을 통한 읽기/쓰기와 읽기 전용
경로의 개념에 대한 내용은 <A HREF="auagd010.htm#HDRWQ208">볼륨 마운트</A>를 참조하십시오.
<P><DT><B>-savevolume
</B><DD>사용자의 볼륨과 VLDB 항목을 보유합니다.
<P><DT><B>-admin
</B><DD><TT>admin</TT> 플래그와 같은 그 인증 데이터베이스 항목에 <B>ADMIN</B>
플래그가 있는 관리 계정을 명명합니다. 암호 프롬프트는 이를 <VAR>admin_user</VAR>로 표시합니다. 적합한 암호를 <VAR>admin_password</VAR>로
입력합니다.
<P><DT><B>-dryrun
</B><DD>명령 인터프리터가 실제로 명령을 수행하지는 않으면서 명령을 수행하기
위해 필요로 하는 조치를 기록합니다.
</DL>
</LI><LI>삭제된 사용자 홈 디렉토리가 복제된 볼륨에 상주하면
<A HREF="auagd010.htm#HDRWQ194">읽기/쓰기 볼륨을 복제하려면 (읽기 전용 볼륨 작성)</A>의 설명대로
<B>vos release</B> 명령을 사용하여 볼륨을 해제하십시오.
<P>
<PRE>
   % <B>vos release</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>

</PRE>
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 단계는 홈 디렉토리의 상위 디렉토리 그 자체가 복제된 볼륨의 마운트 포인트가 아니어도
필요합니다(그리고 이런 경우 더 쉽게 지나침). 예를 들어 Example Corporation
템플릿은 <B>/afs/example.com/usr</B> 디렉토리에 사용자 볼륨에 대한
마운트 포인트를 추가합니다. 이는
마운트 포인트이기 보다 일반 디렉토리이므로 <B>/afs/example.com</B> 디렉토리에
마운트된 <B>root.cell</B> 볼륨에 상주합니다. 그 볼륨은 복제되므로
마운트 포인트를 삭제하여 이를 변경한 후 관리자는 <B>vos release</B> 명령을
실행해야 합니다.
</TD></TR></TABLE>
</LI><LI>각 클라이언트 시스템의 로컬 암호 파일(<B>/etc/passwd</B>
또는 동급)에서 사용자 항목을 삭제하십시오. AFS <B>package</B>
유틸리티를 사용하는 경우 파일의 공통 원본 버전에서 해당 항목을 제거하기만
하면 됩니다. 앞으로 사용자의 계정을 재활성화하려는 경우에는 항목을 주석
처리하거나 암호 필드에 별표(*)를 입력하는 것이 더 쉬운 방법입니다.
</LI></OL>
<A NAME="IDX7727"></A>
<A NAME="IDX7728"></A>
<A NAME="IDX7729"></A>
<A NAME="IDX7730"></A>
<A NAME="IDX7731"></A>
<HR><H2><A NAME="HDRWQ488" HREF="auagd002.htm#ToC_568">uss bulk 명령을 사용하여 복수의 계정 작성 및 삭제</A></H2>
<P><B>uss bulk</B> 명령을 사용하면 한 번에 여러 계정을 작성
및 삭제할 수 있습니다. 이 명령을 실행하기 전에 다음을 수행해야 합니다.
<UL>
<LI>계정을 작성하려는 경우에는 <B>uss add</B> 명령을 실행하기
전에 템플릿을 구성하십시오. 단일 <B>uss bulk</B> 명령으로 작성된
모든 계정에 동일한 템플릿이 적용됩니다.
</LI><LI><A HREF="#HDRWQ489">벌크 입력 파일 구성</A>에서 설명하는 것처럼 계정을 작성 및 삭제하고
관련 명령을 실행하는 명령어 벌크 입력 파일을 구성하십시오.
</LI></UL>
<A NAME="IDX7732"></A>
<A NAME="IDX7733"></A>
<P><H3><A NAME="HDRWQ489" HREF="auagd002.htm#ToC_569">벌크 입력 파일 구성</A></H3>
<P>벌크 입력 파일에 <B>add</B>, <B>delete</B>, <B>exec</B>, <B>savevolume</B> 및 <B>delvolume</B>의 다섯 가지 유형의
명령어를 포함시킬 수 있습니다. 다음 절은 그 사용에 대해 설명합니다.
<P><B>add 명령어를 사용한 사용자 계정 작성</B>
<P>각 <B>add</B> 명령어는 단일 사용자 계정을 작성하므로 기본적으로
하나의 <B>uss add</B> 명령을 실행하는 것과 동일합니다.
벌크 입력 파일에서 <B>add</B> 명령어의 수에는 제한이 없습니다.
<P>다음의 명령 구문에 나타난 것처럼 명령문 필드의 순서는
<B>uss add</B> 명령문에 대한 인수의 순서와
일치해야 합니다(명령문 인수의 일부에는 해당 필드가 없음).
<B>uss add</B> 명령의 인수와 같이 많은 필드가
<B>uss</B> 템플릿 파일에 변수 값을 제공합니다.
각 명령어는 파일에서 단일 행으로 지정되어야 하며(맨 끝에만
개행 문자가 있음), 여기에서는 이해를 돕기 위해 여러 행으로
표시한 것입니다.
<PRE>   <B>add</B> <VAR>username</VAR>[<B>:</B><VAR>full_name</VAR>][<B>:</B><VAR>initial_password</VAR>][<B>:</B><VAR>password_expires</VAR>]
   [<B>:</B><VAR>file_server</VAR>][<B>:</B><VAR>partition</VAR>][<B>:</B><VAR>mount_point</VAR>][<B>:</B><VAR>uid</VAR>]
   [<B>:</B><VAR>var1</VAR>][<B>:</B><VAR>var2</VAR>][<B>:</B><VAR>var3</VAR>][<B>:</B><VAR>var4</VAR>][<B>:</B><VAR>var5</VAR>][<B>:</B><VAR>var6</VAR>][<B>:</B><VAR>var7</VAR>][<B>:</B><VAR>var8</VAR>][<B>:</B><VAR>var9</VAR>][<B>:</B>]
</PRE>
<P>각 필드에서 허용되는 값에 대한 자세한 설명을 보려면 <I>AFS Administration Reference</I>의
<B>uss 벌크 입력 파일</B> 참조 페이지나
<A HREF="#HDRWQ483">uss add 명령을 사용하여 AFS 계정을 작성하려면</A>에서 <B>uss add</B>
명령에 대한 해당 인수의 설명을 참조하십시오. 다음은 몇 가지
기본 참고사항입니다.
<UL>
<LI>문자열 <B>uss add</B>가 아니라 반드시
<B>add</B>로만 행을 시작하십시오.
</LI><LI>첫째 인수, <VAR>username</VAR>만 필수입니다. 이 인수는 <B>uss add</B> 명령의 <B>-user</B> 인수에 해당합니다.
</LI><LI><B>uss add</B> 명령의 <B>-realname</B> 인수에 대한 값을 큰 따옴표(")로 묶어야만 하는 경우에도
<VAR>full_name</VAR> 값을 큰 따옴표(")로 묶지 마십시오.
</LI><LI>인수 값을 생략하려면 두 개의 콜론을 공백 없이 사용하여 필드가 비어 있음을
나타내십시오. 해당 명령행 인수가 선택적이거나 해당 변수가 템플릿 파일에
나타나지 않으면 필드를 빈 상태로 둘 수 있습니다. 실제 값을 지정한 마지막
필드 앞에 나오는 모든 필드의 경우 값을 제공하거나 필드가 비어 있음을
나타내야 합니다. 값을 지정한 마지막 필드 다음에는 필드가 비어 있음을
나타낼 수 있으나 반드시 이렇게 할 필요는 없습니다.
</LI><LI>마지막 필드 다음에서 행은 콜론과 개행 문자(<B>&lt;Return></B>)
또는 개행 문자로 끝나야 합니다.
</LI><LI>마지막 9개의 필드는 숫자 변수($1 - $9)에 값을 지정하기 위한 것으로
필드는 숫자 오름차순으로 나열됩니다. 변수는 지정하지 말고 그 값만 지정하십시오.
</LI></UL>
<P><B>delete 명령어를 사용한 사용자 계정 삭제</B>
<P>각 <B>delete</B> 명령어는 단일 사용자 계정을 삭제하므로 기본적으로
하나의 <B>uss delete</B> 명령을 실행하는 것과 동일합니다.
벌크 입력 파일에서 <B>delete</B> 명령어의 수에는 제한이 없습니다.
<P>벌크 입력 파일의 모든 명령어와 마찬가지로 각
<B>delete</B> 명령어는 파일에서 단일 행으로
지정되어야 하며(맨 끝에만 개행 문자가 있음), 출력 화면에서는
이해를 돕기 위해 여러 행으로 표시된 것입니다.
중괄호(<B>{  }</B>)는 함께 사용할 수 없는
두 개의 명령어를 나타내는 데 사용됩니다.
<PRE>   <B>delete</B> <VAR>username</VAR><B>:</B><VAR>mount_point_path</VAR>[:{ <B>savevolume</B> | <B>delvolume</B> }][<B>:</B>]
</PRE>
<P>각 필드에서 허용되는 값에 대한 자세한 설명을 보려면 <I>AFS Administration Reference</I>의
<B>uss 벌크 입력 파일</B> 참조 페이지나
<A HREF="#HDRWQ487">AFS 계정을 삭제하려면</A>에서 <B>uss delete</B>
명령에 대한 해당 인수의 설명을 참조하십시오. 다음은 몇 가지
기본 참고사항입니다.
<UL>
<LI>문자열 <B>uss delete</B>가 아니라 반드시
<B>delete</B>로만 행을 시작하십시오.
</LI><LI>처음 두 인수, <VAR>username</VAR>과 <VAR>mount_point_path</VAR>는 필수입니다.
이들은 <B>uss delete</B> 명령에 대한 <B>-user</B> 및
<B>-mountpoint</B> 인수에 해당합니다.
</LI><LI>선택적인 세 번째 필드는 해당 VLDB 항목과 함께 사용자의 홈 볼륨이 위치하고
있는 파일 서버에서 제거될지 여부를 제어합니다. 다음과 같이 세 가지 값이
사용될 수 있습니다.
<UL>
<LI>값이 없는 경우 템플릿 파일의 이전 <B>savevolume</B> 또는
<B>delvolume</B> 명령어에 의해 설정된 기본 방식에 따라 볼륨과
VLDB 항목을 처리합니다. 기본값이 설정되는 방식에 대해서는 해당 명령어에 대한
다음 설명을 참조하십시오.
</LI><LI>문자열 <B>savevolume</B>은 볼륨과 VLDB 항목을 그대로
보존하고 기본값을 덮어씁니다.
</LI><LI>문자열 <B>delvolume</B>은 볼륨과 VLDB 항목을 제거하고
기본값을 덮어씁니다.
</LI></UL>
</LI><LI>마지막 필드 다음에서 행은 콜론과 개행 문자(<B>&lt;Return></B>)
또는 개행 문자로 끝나야 합니다.
</LI></UL>
<P><B>exec 명령어를 사용하여 명령 또는 스크립트 실행</B>
<P><B>exec</B> 명령어는 지정된 AFS 명령, 컴파일된 프로그램
또는 UNIX 쉘 스크립트 또는 명령을 실행합니다. 명령 프로세서는
<B>uss bulk</B> 명령의 실행자가 AFS 및 로컬 ID를 가지고
있다고 가정하며 이 사람은 명령을 실행하는 데 필요한 권한을 가지고 있어야 합니다.
<P>명령어 구문은 다음과 같습니다.
<PRE>   <B>exec</B> <VAR>command</VAR>
</PRE>
<P><VAR>command</VAR> 문자열을 반드시 큰 따옴표(")나 다른 구분 문자로 묶을
필요는 없습니다.
<P><B>delvolume 및 savevolume 명령어를 사용하여 볼륨의 기본
처리 방식 설정</B>
<P><B>savevolume</B> 및 <B>delvolume</B> 명령어는
벌크 입력 파일에서 볼륨 다음에 나오는 <B>delete</B> 명령어에서
참조하는 볼륨의 기본 처리 방식을 설정합니다. 그 구문은 다음과 같습니다.
<PRE>   <B>savevolume</B>
   <B>delvolume</B>
</PRE>
<P>두 명령어는 선택적이며 인수를 취하지 않습니다. 이 두 명령어 모두 벌크
입력 파일에 나타나지 않으면 기본적으로 <B>delete</B> 명령어가
참조하는 모든 볼륨 및 VLDB 항목이 제거됩니다. <B>savevolume</B> 명령어가 파일에 나타나면 파일의 모든 후속
<B>delete</B> 명령어에서 참조하는 볼륨 및 VLDB 항목의
제거가 수행되지 않습니다. <B>delvolume</B> 명령어는 후속
<B>delete</B> 명령어의 기본 작동 방식(삭제)을 명시적으로
설정합니다.
<P>두 명령어의 효과는 벌크 입력 파일이 끝날 때까지 또는
상대 명령어가 나타날 때까지 지속됩니다. 특정
<B>delete</B> 명령어에 대한 기본 작동
방식을 덮어쓰려면 명령어의 세 번째 필드에
<B>savevolume</B> 또는 <B>delvolume</B>
문자열을 추가하십시오(또는 <B>savevolume</B> 및
<B>delvolume</B> 명령어의 여러 인스턴스를 사용하여
볼륨의 기본 유지 및 삭제간에 토글할 수 있습니다).
<P><H3><A NAME="Header_570" HREF="auagd002.htm#ToC_570">예제 벌크 입력 파일 명령어</A></H3>
<P>인증 전용 계정을 작성하려면 다음 예제에서처럼 첫째 (<VAR>username</VAR>) 인수만
포함하여 <B>add</B> 명령어를 사용하십시오. 사용자의 실제
이름은 사용자 이름(<B>anderson</B>)과 일치하도록 설정되며
초기 암호는 문자열 <B>changeme</B>으로 설정됩니다.
<PRE>   add anderson
</PRE>
<P>다음 예제에서도 인증 전용 계정을 작성하지만 실제 이름과 초기 암호에 대해
비기본 값을 설정합니다.
<PRE>   add smith:John Smith:js_pswd
</PRE>
<P>다음 두 가지 예제 <B>add</B> 명령어는 Example Corporation
셀(<B>example.com</B>)의 관리자가 다음의 <B>V</B>
명령어와 함께 <B>uss</B> 템플릿 파일을 작성하도록
요구합니다.
<PRE>   V user.$USER $SERVER.example.com /vicep$PART 10000 /afs/.example.com/usr/$3/$USER \
       $UID $USER all
</PRE>
<P>마켓팅 부서에서 John Smith라는 사용자와 재무 부서에서 Pat Jones라는 사용자의
계정을 작성하려면 벌크 입력 파일에서 적절한 <B>add</B> 명령어는 다음과 같습니다.
<PRE>   add smith:John Smith:::fs1:a:::::marketing
   add jones:Pat Jones:::fs3:c:::::finance
</PRE>
<P>Smith의 새로운 계정은 <B>smith</B>라는 보호 및 인증 데이터베이스로
구성됩니다. 초기 암호는 기본 문자열인 <B>changeme</B>이고
보호 서버는 이 사용자의 AFS UID를 생성합니다. <B>user.smith</B>라는
홈 볼륨은 10,000 KB의 할당량을 가지며 파일 서버 시스템 <B>fs1.example.com</B>의
파티션 <B>/vicepa</B>에 위치하며 <B>/afs/.example.com/usr/marketing/smith</B>에 마운트됩니다. <B>V</B>
명령어의 마지막 <B>$UID $USER all</B> 부분은 이 사용자에게
홈 디렉토리에 대한 소유권과 그 ACL에 대한 모든 권한을 부여합니다.
<B>jones</B>의 계정은 파일 서버 시스템 <B>fs3.example.com</B>의
<B>/vicepc</B> 파티션에 위치하고
<B>/afs/.example.com/usr/finance/jones</B>에 마운트된다는 점을
제외하고는 동일합니다.
<P><VAR>mount_point</VAR>, <VAR>uid</VAR>, <VAR>var1</VAR> 및 <VAR>var2</VAR>에
해당하는 필드는 해당 변수가 템플릿 파일의 <B>V</B>
명령어에 나타나지 않으므로 비어 있다는 사실(첫째 예제 행의 값 <TT>a</TT>와 <TT>marketing</TT>)을 알아 두십시오. <VAR>initial_passwd</VAR> 및
<VAR>password_expires</VAR> 필드 역시 비어 있습니다.
<P>원하는 경우 <B>add</B> 명령어에서 9개의 모든 변수에 대해
값을 지정하거나 필드를 비워 둘 수 있습니다. 이 경우 벌크 입력 파일
명령어는 다음과 같습니다.
<PRE>   add smith:John Smith:::fs1:a:::::marketing::::::
   add jones:Pat Jones:::fs3:c:::::finance::::::
</PRE>
<P>다음 예제는 많은 <B>delete</B> 명령어 및 <B>savevolume</B>
명령어가 사용된 벌크 입력 파일 섹션입니다. 처음 세 개의 명령어가
<B>savevolume</B> 명령어 앞에 나오고 셋째 필드가 비어
있으므로 해당 볼륨 및 VLDB 항목은 제거됩니다. 사용자 <B>terry</B>에
대한 <B>delete</B> 명령어는 <B>savevolume</B>
명령어 뒤에 나오므로 이 사용자에 대한 볼륨은 제거되지 않으나 사용자
<B>johnson</B>에 대한 볼륨은 <B>delete</B>
명령어의 셋째 필드에 있는 <B>delvolume</B> 문자열이 현재
기본값을 덮어쓰므로 제거됩니다.
<PRE>   delete smith:/afs/example.com/usr/smith
   delete pat:/afs/example.com/usr/pat
   delete rogers:/afs/example.com/usr/rogers
   savevolume
   delete terry:/afs/example.com/usr/terry
   delete johnson:/afs/example.com/usr/johnson:delvolume
</PRE>
<P>다음의 예제 <B>exec</B> 명령어는
<B>add</B> 명령어 집합과
<B>delete</B> 명령어 집합간의 분리자로서
유용하게 사용됩니다. 이 명령어는 사용자에게
<B>uss bulk</B> 명령의 진행 과정을 알려주는
표준 출력 스트림에 메시지를 생성합니다.
<PRE>   exec echo "Additions completed; beginning deletions..."
</PRE>
<P><H3><A NAME="Header_571" HREF="auagd002.htm#ToC_571">복수의 AFS 사용자 계정을 작성 및 삭제하려면</A></H3>
<OL TYPE=1>
<LI>다음 특권을 전부 사용하여 AFS ID를 인증하십시오. 전형적인
구성에서 <B>admin</B> 사용자 계정에는 이것이
들어 있거나 사용자에게 개인 관리 계정이 있을 수 있습니다(셀
보안을 증가하려면 관리 프로시듀어를 수행하는 중에만 사용할
수 있도록 특별 권한 계정을 작성하는 것이 가장 좋습니다. 더
자세한 내용은 <A HREF="auagd021.htm#HDRWQ584">관리 특권 개요</A>를 참조하십시오).
필요한 경우 <B>klog</B> 명령을 실행하여
인증하십시오.
<P>
<PRE>   % <B>klog</B> <VAR>admin_user</VAR>
   Password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>다음 목록은 필요한 특권을 지정하고 이를 가지고 있는지 확인하는 방법을 나타냅니다.
<UL>
<LI><B>system:administrators</B> 그룹에서의 멤버쉽.
필요하면 <A HREF="auagd021.htm#HDRWQ587">system:administrators 그룹 구성원을 표시하려면</A>에서 자세히 설명되어 있는
<B>pts membership</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>pts membership system:administrators</B>

</PRE>
</LI><LI><B>/usr/afs/etc/UserList</B> 파일에 포함.
필요하면 <A HREF="auagd021.htm#HDRWQ593">UserList 파일에서 사용자를 표시하려면</A>에서 자세히 설명되어 있는
<B>bos listusers</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>bos listusers</B> &lt;<VAR>machine name</VAR>>
</PRE>
</LI><LI>인증 데이터베이스 항목의 <TT>ADMIN</TT> 플래그. 그러나 인증 서버는
자체의 인증을 수행하기 위해 항상 사용자에게 암호를 묻습니다. 다음 명령어는
<B>uss</B> 명령행 자체에 관리 ID를 지정하도록 지시합니다.
</LI><LI>각 볼륨 마운트 포인트에 대한 상위 디렉토리의 ACL에 대한
<B>d</B>(<B>삭제</B>), <B>i</B>(<B>삽입</B>) 및 <B>l</B>(<B>조회</B>) 권한.
필요하면 <A HREF="auagd020.htm#HDRWQ572">ACL 표시</A>에서 자세히 설명되어 있는
<B>fs listacl</B> 명령을 실행하십시오.
<P>
<PRE>   % <B>fs listacl</B> [&lt;<VAR>dir/file path</VAR>>]
</PRE>
<P>
<P><B>system:administrators</B> 그룹의 구성원은 항상 모든 ACL에
대해 암시적으로 <B>a</B>(<B>administer</B>)
권한을 가지며, 기본적으로는 <B>l</B>(<B>lookup</B>)
권한을 가지며 필요한 경우 <B>fs setacl</B> 명령을 사용하여
다른 권한을 부여할 수 있습니다.
</LI></UL>
</LI><LI><B>(선택적)</B> 로컬 수퍼유저 <B>루트</B>로서 로그인하십시오. 이것은 로컬 파일 시스템에 새 파일이나
디렉토리를 작성하며 오브젝트가 작성될 때 대체 소유자를 지정하려는 경우에만
필요합니다. 관련 문제점에 대한 설명을 보려면 <A HREF="#HDRWQ470">로컬 디스크 디렉토리 및 파일 작성에 대하여</A>를
참조하십시오.
</LI><LI>벌크 입력 파일에 <B>add</B> 명령어가
포함된 경우 사용중인 템플릿의 위치와 기능을 확인하십시오.
<B>uss</B> 명령 인터프리터가 해당 템플릿을
어디에서 찾을지에 대한 설명을 보려면
<A HREF="#HDRWQ468">템플릿 파일을 저장할 위치</A>를 참조하십시오. 원하는 경우
항상 대체 경로 이름을 제공할 수 있습니다. 또한 템플릿에
나타나는 변수를 확인하여 <B>add</B> 명령문이나
<B>uss bulk</B> 명령행에 올바른 인수를
제공했는지 확인하십시오.
</LI><LI><A HREF="#HDRWQ489">벌크 입력 파일 구성</A>에 나열된 규칙을 따르는
벌크 입력 파일을 작성하십시오. 사용중인 템플릿 파일과 동일한
디렉토리에 파일을 추가하는 것이 가장 간단합니다.
</LI><LI><B>(선택적)</B> 벌크 입력 파일과 템플릿
파일이 있는 디렉토리로 변경하십시오.
<P>
<PRE>   % <B>cd</B> <VAR>template_directory</VAR>
</PRE>
<A NAME="IDX7734"></A>
<A NAME="IDX7735"></A>
</LI><LI><A NAME="LIWQ490"></A><B>uss bulk</B> 명령을
실행하여 계정을 작성 또는 삭제하십시오. 단일 행에 명령을
입력하십시오. 여기에서는 이해하기 편리하도록 여러 행으로
나타낸 것입니다.
<P>
<P>벌크 조작은 항상 인증 데이터베이스의 사용자 항목을 처리합니다.
인증 서버는 기존 AFS 토큰을 사용하지 않고 자신의 인증 프로세스를
수행합니다. 기본적으로 이것은 로컬(UNIX) ID를 인증하며, AFS가 특권을
부여한 관리자에 해당되지 않을 수 있습니다.
<B>-admin</B> 인수를 삽입하여 인증 데이터베이스
항목에 <TT>ADMIN</TT> 플래그가 있는 ID의 이름을 지정하십시오.
항목에 플래그가 있는 지 확인하려면, <A HREF="auagd021.htm#HDRWQ590">ADMIN 플래그가 설정되어 있는지 확인하려면</A>에서
설명한 것처럼 <B>kas examine</B> 명령을 실행하십시오.
<P>
<PRE>   %
<B>uss bulk</B> &lt;<VAR>bulk&nbsp;input&nbsp;file</VAR>>  \
              [<B>-template</B> &lt;<VAR>pathname&nbsp;of&nbsp;template&nbsp;file</VAR>>]  \
              <B>-admin</B> &lt;<VAR>administrator&nbsp;to&nbsp;authenticate</VAR>>  \
              [<B>-dryrun</B>] [<B>-overwrite</B>]  \
              [<B>-pwexpires</B> &lt;<VAR>password&nbsp;expires&nbsp;in&nbsp;[0..254]&nbsp;days&nbsp;(0&nbsp;=>&nbsp;never)></VAR>]  \
              [<B>-pipe</B>]
    Administrator's (<VAR>admin_user</VAR>) password: <VAR>admin_password</VAR>
</PRE>
<P>
<P>여기서,
<P>
<DL>
<P><DT><B><B>b</B>
</B><DD>허용되는 <B>bulk</B>의 가장 짧은 축약형입니다.
<P><DT><B><VAR>bulk input file</VAR>
</B><DD>벌크 입력 파일의 경로 이름을 지정합니다. 부분적 경로
이름은 현재 작업 디렉토리와의 관계에 따라 해석됩니다. 필요한
파일 형식에 대한 설명을 보려면 <A HREF="#HDRWQ489">벌크 입력 파일 구성</A>을
참조하십시오.
<P><DT><B>-template
</B><DD>벌크 입력 파일에 나타나는 <B>uss add</B>
명령에 대한 템플릿 파일의 경로 이름을 지정합니다. 부분적 경로
이름은 현재 작업 디렉토리와의 관계에 따라 해석됩니다. 필요한
파일 형식에 대한 설명을 보려면 <A HREF="#HDRWQ463">uss 템플릿 파일 구성</A>을
참조하십시오.
<P><DT><B>-admin
</B><DD><TT>admin</TT> 플래그와 같은 그 인증 데이터베이스 항목에
<B>ADMIN</B> 플래그가 있는 관리 계정을 명명합니다.
암호 프롬프트는 이를 <VAR>admin_user</VAR>로 표시합니다. 적합한
암호를 <VAR>admin_password</VAR>로 입력합니다.
<P><DT><B>-dryrun
</B><DD>명령 인터프리터가 실제로 명령을 수행하지는 않으면서
명령을 수행하기 위해 필요로 하는 조치를 기록합니다.
<P><DT><B><B>-overwrite</B>
</B><DD>파일 시스템에 존재하고 <B>-template</B>
인수에 의해 명명된 템플릿 파일의 <B>D</B>,
<B>E</B>, <B>F</B>,
<B>L</B> 또는 <B>S</B> 명령어에
그 정의가 있는 디렉토리, 파일 및 연결을 덮어씁니다. 이 플래그를
생략하면 명령 인터프리터는 벌크 입력 파일에서
각 <B>add</B> 명령어가 나올 때마다 한 번씩
이러한 요소를 덮어쓸지 확인하는 메시지를 표시합니다. 벌크
입력 파일에 <B>add</B> 명령어가 없을 때는
이 플래그를 포함시키지 마십시오.
<P><DT><B><B>-pwexpires</B>
</B><DD>벌크 입력 파일에서 <B>add</B> 명령어에
의해 명명된 각 사용자에 대해 암호가 변경된 이후에 유효한
상태로 남아 있는 일 수를 설정합니다. 범위
<B>1</B> - <B>254</B>의
정수를 지정하여 만기가 될 때까지의 일 수를 지정하거나 값
<B>0</B>을 지정하여 암호가 절대 만기되지
않도록(기본값) 지정하십시오.
<P>
<P>암호가 유효하지 않게 되면(만기) 사용자는 인증을 받을 수 없게
되지만 30일 내에 <B>kpasswd</B> 명령을 실행하여
암호를 변경할 수 있습니다(그 이후에는 관리자가 이를 변경해야 함).
<P><DT><B><B>-pipe</B>
</B><DD>인증 서버가 <B>-admin</B> 인수에서
명명한 실행자나 사용자의 암호를 묻는 메시지를 출력하지
않게 합니다(인증 서버는 항상 인증 데이터베이스에서 항목을
작성하거나 삭제하고 있는 사용자를 별도로 인증합니다). 대신
명령 인터프리터는 다른 프로그램으로부터의 파이프된
입력으로서 암호를 허용하여 사용자가 무인 일괄 작업으로
<B>uss bulk</B> 명령을 실행할 수 있게 합니다.
</DL>
</LI><LI>새로 작성했거나 삭제된 사용자 홈 디렉토리가 복제된
볼륨에 상주하면 <A HREF="auagd010.htm#HDRWQ194">읽기/쓰기 볼륨을 복제하려면 (읽기 전용 볼륨 작성)</A>의 설명대로
<B>vos release</B> 명령을 사용하여 볼륨을
해제하십시오.
<P>
<PRE>
   % <B>vos release</B> &lt;<VAR>volume&nbsp;name&nbsp;or&nbsp;ID</VAR>>

</PRE>
<P>
<TABLE><TR><TD ALIGN="LEFT" VALIGN="TOP"><B>주:</B></TD><TD ALIGN="LEFT" VALIGN="TOP">이 단계는 홈 디렉토리의 상위 디렉토리 그 자체가
복제된 볼륨의 마운트 포인트가 아니어도 필요합니다(그리고
이런 경우 더 쉽게 지나침). 예를 들어 Example Corporation 템플릿은
<B>/afs/example.com/usr</B> 디렉토리에 사용자
볼륨에 대한 마운트 포인트를 추가합니다. 이는 마운트 포인트이기
보다 일반 디렉토리이므로 <B>/afs/example.com</B>
디렉토리에 마운트된 <B>root.cell</B> 볼륨에
상주합니다. 그 볼륨은 복제되므로 마운트 포인트를 작성 또는
삭제하여 이를 변경한 후 관리자는
<B>vos release</B> 명령을 실행해야 합니다.
</TD></TR></TABLE>
</LI><LI>계정을 작성하는 경우 사용자가 로그온할 수 있는 각 AFS
클라이언트 시스템의 로컬 암호 파일(<B>/etc/passwd</B>
또는 동급)에 새 사용자에 대한 항목을 작성하십시오. 이 단계를
자동화하는 방법에 대해서는 <A HREF="#HDRWQ458">공통 원본 암호 파일 작성</A>을
참조하십시오.
<P>
<P>자동화 방법을 사용하지 않는 경우에도 사용자의 UNIX UID가 보호 서버에서
자동으로 지정했거나 <B>-uid</B> 인수를 사용하여 지정한
AFS UID에 일치하도록 설정하십시오. 새로운 사용자의 AFS UID가
<B>uss add</B> 출력에서 생성한 추적에 나타나거나
<A HREF="auagd019.htm#HDRWQ537">보호 데이터베이스 항목을 표시하려면</A>에서 설명하는 것처럼
<B>pts examine</B> 명령을 사용하여 표시할 수 있습니다.
</LI><LI>계정을 삭제하는 경우 각 클라이언트 시스템의 로컬 암호
파일(<B>/etc/passwd</B> 또는 동급)에서 사용자
항목을 삭제하십시오. AFS <B>package</B> 유틸리티를
사용하는 경우 파일의 공통 원본 버전에서 해당 항목을 제거하기만
하면 됩니다. 앞으로 사용자의 계정을 재활성화하려는 경우에는
항목을 주석 처리하거나 암호 필드에 별표(*)를 입력하는 것이
더 쉬운 방법입니다.
</LI></OL>
<P><HR><B>&#91; <A HREF="#Top_Of_Page">페이지의 맨 위</A> &#124; <A HREF="auagd016.htm">이전 페이지</A> &#124; <A HREF="auagd018.htm">다음 페이지</A> &#124; <A HREF="auagd002.htm#ToC">목차</A> &#124; <A HREF="auagd026.htm#HDRINDEX">색인</A> &#93;</B>
<!-- Begin Footer Records  ========================================== -->
<P><HR><B>
<br>&#169; <A HREF="http://www.ibm.com/">IBM Corporation 2000.</A>  All Rights Reserved
</B>
<!-- End Footer Records  ============================================ -->
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
